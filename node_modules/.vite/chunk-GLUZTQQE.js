import {
  ClickOutside,
  IN_BROWSER,
  Ripple,
  SUPPORTS_INTERSECTION,
  SUPPORTS_TOUCH,
  acceleratedEasing,
  colorToInt,
  colorToRGB,
  consoleError,
  consoleWarn,
  convertToUnit,
  createRange,
  createSimpleFunctional,
  darken,
  deceleratedEasing,
  deepEqual,
  defineComponent as defineComponent2,
  extract,
  findChildren,
  flattenFragments,
  getLuma,
  getObjectValueByPath,
  getScrollParent,
  getScrollParents,
  getUid,
  intToHex,
  intersect_default,
  isCssColor,
  keyValues,
  lighten,
  mergeDeep,
  nullifyTransforms,
  propsFactory,
  provideDefaults,
  standardEasing,
  toKebabCase,
  useRender,
  wrapInArray,
  wrapInRef
} from "./chunk-U4SLUAWY.js";
import {
  Fragment,
  Teleport,
  Transition,
  TransitionGroup,
  camelize,
  capitalize,
  computed,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  isRef,
  mergeProps,
  nextTick,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  provide,
  reactive,
  readonly,
  ref,
  resolveDirective,
  resolveDynamicComponent,
  toRef,
  toRefs,
  unref,
  vShow,
  warn,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-Y3BF5RTF.js";

// node_modules/vuetify/lib/components/VApp/VApp.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VApp/VApp.sass";

// node_modules/vuetify/lib/util/color/APCA.mjs
var mainTRC = 2.4;
var Rco = 0.2126729;
var Gco = 0.7151522;
var Bco = 0.072175;
var normBG = 0.55;
var normTXT = 0.58;
var revTXT = 0.57;
var revBG = 0.62;
var blkThrs = 0.03;
var blkClmp = 1.45;
var deltaYmin = 5e-4;
var scaleBoW = 1.25;
var scaleWoB = 1.25;
var loConThresh = 0.078;
var loConFactor = 12.82051282051282;
var loConOffset = 0.06;
var loClip = 1e-3;
function APCAcontrast(text, background) {
  const Rtxt = ((text >> 16 & 255) / 255) ** mainTRC;
  const Gtxt = ((text >> 8 & 255) / 255) ** mainTRC;
  const Btxt = ((text >> 0 & 255) / 255) ** mainTRC;
  const Rbg = ((background >> 16 & 255) / 255) ** mainTRC;
  const Gbg = ((background >> 8 & 255) / 255) ** mainTRC;
  const Bbg = ((background >> 0 & 255) / 255) ** mainTRC;
  let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
  let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
  if (Ytxt <= blkThrs)
    Ytxt += (blkThrs - Ytxt) ** blkClmp;
  if (Ybg <= blkThrs)
    Ybg += (blkThrs - Ybg) ** blkClmp;
  if (Math.abs(Ybg - Ytxt) < deltaYmin)
    return 0;
  let outputContrast;
  if (Ybg > Ytxt) {
    const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
    outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
  } else {
    const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
    outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
  }
  return outputContrast * 100;
}

// node_modules/vuetify/lib/composables/theme.mjs
var ThemeSymbol = Symbol.for("vuetify:theme");
var makeThemeProps = propsFactory({
  theme: String
}, "theme");
var defaultThemeOptions = {
  defaultTheme: "light",
  variations: {
    colors: [],
    lighten: 0,
    darken: 0
  },
  themes: {
    light: {
      dark: false,
      colors: {
        background: "#FFFFFF",
        surface: "#FFFFFF",
        primary: "#6200EE",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC6",
        "secondary-darken-1": "#018786",
        error: "#B00020",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#000000",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 0.87,
        "medium-emphasis-opacity": 0.6,
        "disabled-opacity": 0.38,
        "activated-opacity": 0.12,
        "idle-opacity": 0.04,
        "hover-opacity": 0.12,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "dragged-opacity": 0.08,
        "pressed-opacity": 0.16,
        "kbd-background-color": "#212529",
        "kbd-color": "#FFFFFF",
        "code-background-color": "#C2C2C2"
      }
    },
    dark: {
      dark: true,
      colors: {
        background: "#121212",
        surface: "#212121",
        primary: "#BB86FC",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC5",
        "secondary-darken-1": "#03DAC5",
        error: "#CF6679",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#FFFFFF",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 0.87,
        "medium-emphasis-opacity": 0.6,
        "disabled-opacity": 0.38,
        "activated-opacity": 0.12,
        "idle-opacity": 0.1,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "dragged-opacity": 0.08,
        "pressed-opacity": 0.16,
        "kbd-background-color": "#212529",
        "kbd-color": "#FFFFFF",
        "code-background-color": "#B7B7B7"
      }
    }
  }
};
var parseThemeOptions = (options = defaultThemeOptions) => {
  if (!options)
    return {
      ...defaultThemeOptions,
      isDisabled: true
    };
  return mergeDeep(defaultThemeOptions, options);
};
function createTheme(options) {
  const parsedOptions = parseThemeOptions(options);
  const styleEl = ref();
  const current = ref(parsedOptions.defaultTheme);
  const themes = ref(parsedOptions.themes);
  const variations = ref(parsedOptions.variations);
  const computedThemes = computed(() => {
    return Object.keys(themes.value).reduce((obj, key) => {
      var _parsedOptions$variat;
      const theme = {
        ...themes.value[key],
        colors: {
          ...themes.value[key].colors,
          ...((_parsedOptions$variat = parsedOptions.variations.colors) != null ? _parsedOptions$variat : []).reduce((obj2, color) => {
            return {
              ...obj2,
              ...genColorVariations(color, themes.value[key].colors[color])
            };
          }, {})
        }
      };
      for (const color of Object.keys(theme.colors)) {
        if (/on-[a-z]/.test(color) || theme.colors[`on-${color}`])
          continue;
        const onColor = `on-${color}`;
        const colorVal = colorToInt(theme.colors[color]);
        const blackContrast = Math.abs(APCAcontrast(0, colorVal));
        const whiteContrast = Math.abs(APCAcontrast(16777215, colorVal));
        theme.colors[onColor] = whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
      }
      obj[key] = theme;
      return obj;
    }, {});
  });
  function genColorVariations(name, color) {
    const obj = {};
    for (const variation of ["lighten", "darken"]) {
      const fn = variation === "lighten" ? lighten : darken;
      for (const amount of createRange(variations.value[variation], 1)) {
        obj[`${name}-${variation}-${amount}`] = intToHex(fn(colorToInt(color), amount));
      }
    }
    return obj;
  }
  function genCssVariables(name) {
    const theme = computedThemes.value[name];
    if (!theme)
      throw new Error(`Could not find theme ${name}`);
    const lightOverlay = theme.dark ? 2 : 1;
    const darkOverlay = theme.dark ? 1 : 2;
    const variables = [];
    for (const [key, value] of Object.entries(theme.colors)) {
      const rgb = colorToRGB(value);
      variables.push(`--v-theme-${key}: ${rgb.r},${rgb.g},${rgb.b}`);
      if (!key.startsWith("on-")) {
        variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
      }
    }
    return variables;
  }
  function genStyleElement() {
    if (typeof document === "undefined" || styleEl.value)
      return;
    const el = document.createElement("style");
    el.type = "text/css";
    el.id = "vuetify-theme-stylesheet";
    styleEl.value = el;
    document.head.appendChild(styleEl.value);
  }
  function createCssClass(selector, content) {
    return [`${selector} {
`, ...content.map((line) => `  ${line};
`), "}\n"];
  }
  function updateStyles() {
    if (parsedOptions.isDisabled)
      return;
    genStyleElement();
    const lines = [];
    for (const themeName of Object.keys(computedThemes.value)) {
      const variables = computedThemes.value[themeName].variables;
      lines.push(...createCssClass(`.v-theme--${themeName}`, [...genCssVariables(themeName), ...Object.keys(variables).map((key) => {
        const value = variables[key];
        const color = typeof value === "string" && value.startsWith("#") ? colorToRGB(value) : void 0;
        const rgb = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
        return `--v-${key}: ${rgb != null ? rgb : value}`;
      })]));
    }
    const firstTheme = Object.keys(computedThemes.value)[0];
    for (const key of Object.keys(computedThemes.value[firstTheme].colors)) {
      if (/on-[a-z]/.test(key)) {
        lines.push(...createCssClass(`.${key}`, [`color: rgb(var(--v-theme-${key}))`]));
      } else {
        lines.push(...createCssClass(`.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background: rgb(var(--v-theme-${key}))`, `color: rgb(var(--v-theme-on-${key}))`]), ...createCssClass(`.text-${key}`, [`color: rgb(var(--v-theme-${key}))`]), ...createCssClass(`.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]));
      }
    }
    if (styleEl.value)
      styleEl.value.innerHTML = lines.map((str, i) => i === 0 ? str : `    ${str}`).join("");
  }
  watch(themes, updateStyles, {
    deep: true,
    immediate: true
  });
  return {
    isDisabled: parsedOptions.isDisabled,
    themes: computedThemes,
    setTheme: (key, theme) => themes.value[key] = theme,
    getTheme: (key) => computedThemes.value[key],
    current,
    themeClasses: computed(() => parsedOptions.isDisabled ? void 0 : `v-theme--${current.value}`)
  };
}
function useTheme(props) {
  const vm = getCurrentInstance();
  const theme = inject(ThemeSymbol, null);
  if (!vm)
    consoleError("provideTheme must be called from inside a setup function");
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  const current = computed(() => {
    var _props$theme;
    return (_props$theme = props.theme) != null ? _props$theme : theme == null ? void 0 : theme.current.value;
  });
  const themeClasses = computed(() => theme.isDisabled ? void 0 : `v-theme--${current.value}`);
  const newTheme = {
    ...theme,
    current,
    themeClasses
  };
  provide(ThemeSymbol, newTheme);
  return newTheme;
}

// node_modules/vuetify/lib/composables/layout.mjs
var VuetifyLayoutKey = Symbol.for("vuetify:layout");
var makeLayoutProps = propsFactory({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout");
var makeLayoutItemProps = propsFactory({
  name: {
    type: String
  },
  priority: {
    type: Number,
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function useMain() {
  const layout = inject(VuetifyLayoutKey);
  if (!layout)
    throw new Error("Could not find injected Vuetify layout");
  return layout;
}
function useLayoutItem(name, priority, position, layoutSize, elementSize, active) {
  const layout = inject(VuetifyLayoutKey);
  if (!layout)
    throw new Error("Could not find injected Vuetify layout");
  const id = name != null ? name : `layout-item-${getUid()}`;
  const styles = layout.register(id, priority, position, layoutSize, elementSize, active);
  onBeforeUnmount(() => layout.unregister(id));
  return styles;
}
var generateLayers = (layout, registered, positions, layoutSizes, activeItems) => {
  let previousLayer = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const layers = [{
    id: "",
    layer: {
      ...previousLayer
    }
  }];
  const ids = !layout.length ? registered : layout.map((l) => l.split(":")[0]).filter((l) => registered.includes(l));
  for (const id of ids) {
    const position = positions.get(id);
    const amount = layoutSizes.get(id);
    const active = activeItems.get(id);
    if (!position || !amount || !active)
      continue;
    const layer = {
      ...previousLayer,
      [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
    };
    layers.push({
      id,
      layer
    });
    previousLayer = layer;
  }
  return layers;
};
function createLayout(props) {
  const registered = ref([]);
  const positions = new Map();
  const layoutSizes = new Map();
  const priorities = new Map();
  const activeItems = new Map();
  const computedOverlaps = computed(() => {
    var _props$overlaps;
    const map = new Map();
    const overlaps = (_props$overlaps = props.overlaps) != null ? _props$overlaps : [];
    for (const overlap of overlaps.filter((item) => item.includes(":"))) {
      const [top, bottom] = overlap.split(":");
      if (!registered.value.includes(top) || !registered.value.includes(bottom))
        continue;
      const topPosition = positions.get(top);
      const bottomPosition = positions.get(bottom);
      const topAmount = layoutSizes.get(top);
      const bottomAmount = layoutSizes.get(bottom);
      if (!topPosition || !bottomPosition || !topAmount || !bottomAmount)
        continue;
      map.set(bottom, {
        position: topPosition.value,
        amount: parseInt(topAmount.value, 10)
      });
      map.set(top, {
        position: bottomPosition.value,
        amount: -parseInt(bottomAmount.value, 10)
      });
    }
    return map;
  });
  const layers = computed(() => {
    const entries = [...priorities.entries()];
    const sortedEntries = entries.sort(([, a], [, b]) => a.value - b.value).map(([id]) => id);
    return generateLayers(sortedEntries, registered.value, positions, layoutSizes, activeItems);
  });
  const mainStyles = computed(() => {
    const layer = layers.value[layers.value.length - 1].layer;
    return {
      position: "relative",
      paddingLeft: convertToUnit(layer.left),
      paddingRight: convertToUnit(layer.right),
      paddingTop: convertToUnit(layer.top),
      paddingBottom: convertToUnit(layer.bottom)
    };
  });
  const items = computed(() => {
    return layers.value.slice(1).map(({
      id
    }, index) => {
      const {
        layer
      } = layers.value[index];
      const size = layoutSizes.get(id);
      return {
        id,
        ...layer,
        size: Number(size.value)
      };
    });
  });
  const getLayoutItem = (id) => {
    return items.value.find((item) => item.id === id);
  };
  provide(VuetifyLayoutKey, {
    register: (id, priority, position, layoutSize, elementSize, active) => {
      priorities.set(id, priority);
      positions.set(id, position);
      layoutSizes.set(id, layoutSize);
      activeItems.set(id, active);
      registered.value.push(id);
      return computed(() => {
        const index = items.value.findIndex((i) => i.id === id);
        if (index < 0)
          throw new Error(`Layout item "${id}" is missing from layout prop`);
        const item = items.value[index];
        if (!item)
          throw new Error(`Could not find layout item "${id}`);
        const overlap = computedOverlaps.value.get(id);
        if (overlap) {
          item[overlap.position] += overlap.amount;
        }
        const isHorizontal = position.value === "left" || position.value === "right";
        const isOppositeHorizontal = position.value === "right";
        const isOppositeVertical = position.value === "bottom";
        return {
          [position.value]: 0,
          height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : `${elementSize.value}px`,
          marginLeft: isOppositeHorizontal ? void 0 : `${item.left}px`,
          marginRight: isOppositeHorizontal ? `${item.right}px` : void 0,
          marginTop: position.value !== "bottom" ? `${item.top}px` : void 0,
          marginBottom: position.value !== "top" ? `${item.bottom}px` : void 0,
          width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : `${elementSize.value}px`,
          zIndex: layers.value.length - index,
          transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`
        };
      });
    },
    unregister: (id) => {
      priorities.delete(id);
      positions.delete(id);
      layoutSizes.delete(id);
      activeItems.delete(id);
      registered.value = registered.value.filter((v) => v !== id);
    },
    mainStyles,
    getLayoutItem,
    items
  });
  const layoutClasses = computed(() => ["v-layout", {
    "v-layout--full-height": props.fullHeight
  }]);
  return {
    layoutClasses,
    getLayoutItem,
    items
  };
}

// node_modules/vuetify/lib/locale/en.mjs
var en_default = {
  badge: "Badge",
  close: "Close",
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    nextMonthAriaLabel: "Next month",
    nextYearAriaLabel: "Next year",
    prevMonthAriaLabel: "Previous month",
    prevYearAriaLabel: "Previous year"
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Goto Page {0}",
      currentPage: "Page {0}, Current Page",
      first: "First page",
      last: "Last page"
    }
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  }
};

// node_modules/vuetify/lib/locale/index.mjs
var rtl = {
  af: false,
  ar: true,
  bg: false,
  ca: false,
  ckb: false,
  cs: false,
  de: false,
  el: false,
  en: false,
  es: false,
  et: false,
  fa: false,
  fi: false,
  fr: false,
  hr: false,
  hu: false,
  he: true,
  id: false,
  it: false,
  ja: false,
  ko: false,
  lv: false,
  lt: false,
  nl: false,
  no: false,
  pl: false,
  pt: false,
  ro: false,
  ru: false,
  sk: false,
  sl: false,
  srCyrl: false,
  srLatn: false,
  sv: false,
  th: false,
  tr: false,
  az: false,
  uk: false,
  vi: false,
  zhHans: false,
  zhHant: false
};

// node_modules/vuetify/lib/composables/rtl.mjs
var RtlSymbol = Symbol.for("vuetify:rtl");
function createRtl(localeScope, options) {
  var _options$rtl, _options$defaultRtl;
  return createRtlScope({
    rtl: {
      ...rtl,
      ...(_options$rtl = options == null ? void 0 : options.rtl) != null ? _options$rtl : {}
    },
    isRtl: ref((_options$defaultRtl = options == null ? void 0 : options.defaultRtl) != null ? _options$defaultRtl : false),
    rtlClasses: ref("")
  }, localeScope);
}
function createRtlScope(currentScope, localeScope, options) {
  const isRtl = computed(() => {
    if (typeof (options == null ? void 0 : options.rtl) === "boolean")
      return options.rtl;
    if (localeScope.current.value && currentScope.rtl.hasOwnProperty(localeScope.current.value)) {
      return currentScope.rtl[localeScope.current.value];
    }
    return currentScope.isRtl.value;
  });
  return {
    isRtl,
    rtl: currentScope.rtl,
    rtlClasses: computed(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
  };
}
function provideRtl(props, localeScope) {
  const currentScope = inject(RtlSymbol);
  if (!currentScope)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  const newScope = createRtlScope(currentScope, localeScope, props);
  provide(RtlSymbol, newScope);
  return newScope;
}
function useRtl() {
  const currentScope = inject(RtlSymbol);
  if (!currentScope)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return currentScope;
}

// node_modules/vuetify/lib/components/VApp/VApp.mjs
var VApp_default = defineComponent2({
  name: "VApp",
  props: {
    ...makeLayoutProps({
      fullHeight: true
    }),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      layoutClasses
    } = createLayout(props);
    const {
      rtlClasses
    } = useRtl();
    return () => {
      var _slots$default;
      return createVNode("div", {
        "class": ["v-application", themeClasses.value, layoutClasses.value, rtlClasses.value],
        "data-app": "true"
      }, [createVNode("div", {
        "class": "v-application__wrap"
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)])], 2);
    };
  }
});

// node_modules/vuetify/lib/components/VResponsive/VResponsive.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VResponsive/VResponsive.sass";

// node_modules/vuetify/lib/composables/dimensions.mjs
var makeDimensionProps = propsFactory({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function useDimension(props) {
  const dimensionStyles = computed(() => ({
    height: convertToUnit(props.height),
    maxHeight: convertToUnit(props.maxHeight),
    maxWidth: convertToUnit(props.maxWidth),
    minHeight: convertToUnit(props.minHeight),
    minWidth: convertToUnit(props.minWidth),
    width: convertToUnit(props.width)
  }));
  return {
    dimensionStyles
  };
}

// node_modules/vuetify/lib/components/VResponsive/VResponsive.mjs
function useAspectStyles(props) {
  return {
    aspectStyles: computed(() => {
      const ratio = Number(props.aspectRatio);
      return ratio ? {
        paddingBottom: String(1 / ratio * 100) + "%"
      } : void 0;
    })
  };
}
var VResponsive_default = defineComponent2({
  name: "VResponsive",
  props: {
    aspectRatio: [String, Number],
    contentClass: String,
    ...makeDimensionProps()
  },
  setup(props, {
    slots
  }) {
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      aspectStyles
    } = useAspectStyles(props);
    return () => {
      var _slots$additional;
      return createVNode("div", {
        "class": "v-responsive",
        "style": dimensionStyles.value
      }, [createVNode("div", {
        "class": "v-responsive__sizer",
        "style": aspectStyles.value
      }, null, 4), (_slots$additional = slots.additional) == null ? void 0 : _slots$additional.call(slots), slots.default && createVNode("div", {
        "class": ["v-responsive__content", props.contentClass]
      }, [slots.default()], 2)], 4);
    };
  }
});

// node_modules/vuetify/lib/components/VImg/VImg.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VImg/VImg.sass";

// node_modules/vuetify/lib/composables/transition.mjs
var makeTransitionProps = propsFactory({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (val) => val !== true
  }
}, "transition");
var MaybeTransition = (props, {
  slots
}) => {
  var _slots$default;
  const {
    transition,
    ...rest
  } = props;
  if (!transition || typeof transition === "boolean")
    return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
  const {
    component = Transition,
    ...customProps
  } = typeof transition === "object" ? transition : {};
  return h(component, mergeProps(typeof transition === "string" ? {
    name: transition
  } : customProps, rest), slots);
};

// node_modules/vuetify/lib/components/VImg/VImg.mjs
var VImg_default = defineComponent2({
  name: "VImg",
  directives: {
    intersect: intersect_default
  },
  props: {
    aspectRatio: [String, Number],
    alt: String,
    cover: Boolean,
    eager: Boolean,
    lazySrc: String,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    },
    position: {
      type: String,
      default: "center center"
    },
    sizes: String,
    src: {
      type: [String, Object],
      default: ""
    },
    srcset: String,
    ...makeTransitionProps()
  },
  emits: ["loadstart", "load", "error"],
  setup(props, {
    emit,
    slots
  }) {
    const currentSrc = ref("");
    const image = ref();
    const state = ref(props.eager ? "loading" : "idle");
    const naturalWidth = ref();
    const naturalHeight = ref();
    const normalisedSrc = computed(() => {
      return props.src && typeof props.src === "object" ? {
        src: props.src.src,
        srcset: props.srcset || props.src.srcset,
        lazySrc: props.lazySrc || props.src.lazySrc,
        aspect: Number(props.aspectRatio || props.src.aspect)
      } : {
        src: props.src,
        srcset: props.srcset,
        lazySrc: props.lazySrc,
        aspect: Number(props.aspectRatio || 0)
      };
    });
    const aspectRatio = computed(() => {
      return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
    });
    watch(() => props.src, () => {
      init(state.value !== "idle");
    });
    onBeforeMount(() => init());
    function init(isIntersecting) {
      if (props.eager && isIntersecting)
        return;
      if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager)
        return;
      state.value = "loading";
      nextTick(() => {
        var _image$value, _image$value2;
        emit("loadstart", ((_image$value = image.value) == null ? void 0 : _image$value.currentSrc) || normalisedSrc.value.src);
        if ((_image$value2 = image.value) != null && _image$value2.complete) {
          if (!image.value.naturalWidth) {
            onError();
          }
          if (state.value === "error")
            return;
          if (!aspectRatio.value)
            pollForSize(image.value, null);
          onLoad();
        } else {
          if (!aspectRatio.value)
            pollForSize(image.value);
          getSrc();
        }
      });
      if (normalisedSrc.value.lazySrc) {
        const lazyImg = new Image();
        lazyImg.src = normalisedSrc.value.lazySrc;
        pollForSize(lazyImg, null);
      }
    }
    function onLoad() {
      var _image$value3;
      getSrc();
      state.value = "loaded";
      emit("load", ((_image$value3 = image.value) == null ? void 0 : _image$value3.currentSrc) || normalisedSrc.value.src);
    }
    function onError() {
      var _image$value4;
      state.value = "error";
      emit("error", ((_image$value4 = image.value) == null ? void 0 : _image$value4.currentSrc) || normalisedSrc.value.src);
    }
    function getSrc() {
      const img = image.value;
      if (img)
        currentSrc.value = img.currentSrc || img.src;
    }
    function pollForSize(img, timeout = 100) {
      const poll = () => {
        const {
          naturalHeight: imgHeight,
          naturalWidth: imgWidth
        } = img;
        if (imgHeight || imgWidth) {
          naturalWidth.value = imgWidth;
          naturalHeight.value = imgHeight;
        } else if (!img.complete && state.value === "loading" && timeout != null) {
          setTimeout(poll, timeout);
        } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
          naturalWidth.value = 1;
          naturalHeight.value = 1;
        }
      };
      poll();
    }
    const containClasses = computed(() => ({
      "v-img__img--cover": props.cover,
      "v-img__img--contain": !props.cover
    }));
    const __image = computed(() => {
      var _slots$sources;
      if (!normalisedSrc.value.src || state.value === "idle")
        return;
      const img = h("img", {
        class: ["v-img__img", containClasses.value],
        src: normalisedSrc.value.src,
        srcset: normalisedSrc.value.srcset,
        sizes: props.sizes,
        ref: image,
        onLoad,
        onError
      });
      const sources = (_slots$sources = slots.sources) == null ? void 0 : _slots$sources.call(slots);
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [withDirectives(sources ? createVNode("picture", {
          "class": "v-img__picture"
        }, [sources, img]) : img, [[vShow, state.value === "loaded"]])],
        _: 2
      }, 8, ["transition", "appear"]);
    });
    const __preloadImage = computed(() => createVNode(MaybeTransition, {
      "transition": props.transition
    }, {
      default: () => [normalisedSrc.value.lazySrc && state.value !== "loaded" && createVNode("img", {
        "class": ["v-img__img", "v-img__img--preload", containClasses.value],
        "src": normalisedSrc.value.lazySrc,
        "alt": ""
      }, null, 10, ["src"])]
    }, 8, ["transition"]));
    const __placeholder = computed(() => {
      if (!slots.placeholder)
        return;
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [(state.value === "loading" || state.value === "error" && !slots.error) && createVNode("div", {
          "class": "v-img__placeholder"
        }, [slots.placeholder()])]
      }, 8, ["transition", "appear"]);
    });
    const __error = computed(() => {
      if (!slots.error)
        return;
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [state.value === "error" && createVNode("div", {
          "class": "v-img__error"
        }, [slots.error()])]
      }, 8, ["transition", "appear"]);
    });
    useRender(() => withDirectives(createVNode(VResponsive_default, {
      "class": "v-img",
      "aspectRatio": aspectRatio.value,
      "aria-label": props.alt,
      "role": props.alt ? "img" : void 0
    }, {
      additional: () => [__image.value, __preloadImage.value, __placeholder.value, __error.value],
      default: slots.default
    }, 8, ["aspectRatio", "aria-label", "role"]), [[resolveDirective("intersect"), {
      handler: init,
      options: props.options
    }, null, {
      once: true
    }]]));
    return {
      currentSrc,
      image,
      state,
      naturalWidth,
      naturalHeight
    };
  }
});

// node_modules/vuetify/lib/components/VAppBar/VAppBar.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VAppBar/VAppBar.sass";

// node_modules/vuetify/lib/composables/border.mjs
var makeBorderProps = propsFactory({
  border: [Boolean, Number, String]
}, "border");
function useBorder(props, name) {
  const borderClasses = computed(() => {
    const classes = [];
    if (props.border != null && props.border !== false) {
      classes.push(`${name}--border`);
    }
    if (typeof props.border === "string" && props.border !== "" || props.border === 0) {
      for (const value of String(props.border).split(" ")) {
        classes.push(`border-${value}`);
      }
    }
    return classes;
  });
  return {
    borderClasses
  };
}

// node_modules/vuetify/lib/composables/density.mjs
var allowedDensities = [null, "default", "comfortable", "compact"];
var makeDensityProps = propsFactory({
  density: {
    type: String,
    default: "default",
    validator: (v) => allowedDensities.includes(v)
  }
}, "density");
function useDensity(props, name) {
  const densityClasses = computed(() => {
    return `${name}--density-${props.density}`;
  });
  return {
    densityClasses
  };
}

// node_modules/vuetify/lib/composables/elevation.mjs
var makeElevationProps = propsFactory({
  elevation: {
    type: [Number, String],
    validator(v) {
      const value = parseInt(v);
      return !isNaN(value) && value >= 0 && value <= 24;
    }
  }
}, "elevation");
function useElevation(props) {
  const elevationClasses = computed(() => {
    const classes = [];
    if (props.elevation == null)
      return classes;
    classes.push(`elevation-${props.elevation}`);
    return classes;
  });
  return {
    elevationClasses
  };
}

// node_modules/vuetify/lib/composables/rounded.mjs
var makeRoundedProps = propsFactory({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  },
  tile: Boolean
}, "rounded");
function useRounded(props, name) {
  const roundedClasses = computed(() => {
    const classes = [];
    if (props.tile) {
      classes.push(`${name}--tile`);
    } else if (props.rounded === true || props.rounded === "") {
      classes.push(`${name}--rounded`);
    } else if (typeof props.rounded === "string" || props.rounded === 0) {
      for (const value of String(props.rounded).split(" ")) {
        classes.push(`rounded-${value}`);
      }
    }
    return classes;
  });
  return {
    roundedClasses
  };
}

// node_modules/vuetify/lib/composables/tag.mjs
var makeTagProps = propsFactory({
  tag: {
    type: String,
    default: "div"
  }
}, "tag");

// node_modules/vuetify/lib/composables/color.mjs
function useColor(colors) {
  const backgroundIsCssColor = computed(() => isCssColor(colors.value.background));
  const textIsCssColor = computed(() => isCssColor(colors.value.text));
  const colorClasses = computed(() => {
    const classes = [];
    if (colors.value.background && !backgroundIsCssColor.value) {
      classes.push(`bg-${colors.value.background}`);
    }
    if (colors.value.text && !textIsCssColor.value) {
      classes.push(`text-${colors.value.text}`);
    }
    return classes;
  });
  const colorStyles = computed(() => {
    const styles = {};
    if (colors.value.background && backgroundIsCssColor.value) {
      styles.backgroundColor = colors.value.background;
    }
    if (colors.value.text && textIsCssColor.value) {
      styles.color = colors.value.text;
      styles.caretColor = colors.value.text;
    }
    return styles;
  });
  return {
    colorClasses,
    colorStyles
  };
}
function useTextColor(props, name) {
  const colors = computed(() => ({
    text: isRef(props) ? props.value : name ? props[name] : null
  }));
  const {
    colorClasses: textColorClasses,
    colorStyles: textColorStyles
  } = useColor(colors);
  return {
    textColorClasses,
    textColorStyles
  };
}
function useBackgroundColor(props, name) {
  const colors = computed(() => ({
    background: isRef(props) ? props.value : name ? props[name] : null
  }));
  const {
    colorClasses: backgroundColorClasses,
    colorStyles: backgroundColorStyles
  } = useColor(colors);
  return {
    backgroundColorClasses,
    backgroundColorStyles
  };
}

// node_modules/vuetify/lib/composables/proxiedModel.mjs
function useProxiedModel(props, prop, defaultValue, transformIn = (v) => v, transformOut = (v) => v) {
  const vm = getCurrentInstance();
  if (!vm)
    consoleError("useProxiedModel must be called from inside a setup function");
  const propIsDefined = computed(() => {
    var _vm$vnode$props, _vm$vnode$props2;
    return !!(typeof props[prop] !== "undefined" && (vm != null && (_vm$vnode$props = vm.vnode.props) != null && _vm$vnode$props.hasOwnProperty(prop) || vm != null && (_vm$vnode$props2 = vm.vnode.props) != null && _vm$vnode$props2.hasOwnProperty(toKebabCase(prop))));
  });
  const internal = ref(transformIn(props[prop]));
  return computed({
    get() {
      if (propIsDefined.value)
        return transformIn(props[prop]);
      else
        return internal.value;
    },
    set(newValue) {
      internal.value = newValue;
      vm == null ? void 0 : vm.emit(`update:${prop}`, transformOut(newValue));
    }
  });
}

// node_modules/vuetify/lib/components/VAppBar/VAppBar.mjs
var VAppBar_default = defineComponent2({
  name: "VAppBar",
  props: {
    collapse: Boolean,
    color: String,
    flat: Boolean,
    height: {
      type: [Number, String],
      default: 64
    },
    extensionHeight: {
      type: [Number, String],
      default: 48
    },
    floating: Boolean,
    image: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    prominent: Boolean,
    prominentHeight: {
      type: [Number, String],
      default: 128
    },
    position: {
      type: String,
      default: "top",
      validator: (value) => ["top", "bottom"].includes(value)
    },
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeLayoutItemProps({
      name: "app-bar"
    }),
    ...makeTagProps({
      tag: "header"
    })
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, {
    slots
  }) {
    const {
      borderClasses
    } = useBorder(props, "v-app-bar");
    const {
      densityClasses
    } = useDensity(props, "v-app-bar");
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, "v-app-bar");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const isExtended = !!slots.extension;
    const contentHeight = computed(() => Number(props.prominent ? props.prominentHeight : props.height) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0));
    const height = computed(() => contentHeight.value + Number(isExtended ? props.extensionHeight : 0));
    const isActive = useProxiedModel(props, "modelValue", props.modelValue);
    const layoutStyles = useLayoutItem(props.name, toRef(props, "priority"), toRef(props, "position"), height, height, isActive);
    return () => {
      var _slots$img, _slots$default, _slots$extension;
      const hasImage = !!(slots.image || props.image);
      return createVNode(props.tag, {
        "class": ["v-app-bar", {
          "v-app-bar--bottom": props.position === "bottom",
          "v-app-bar--collapsed": props.collapse,
          "v-app-bar--flat": props.flat,
          "v-app-bar--floating": props.floating,
          "v-app-bar--is-active": isActive.value,
          "v-app-bar--prominent": props.prominent,
          "v-app-bar--absolute": props.absolute
        }, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, layoutStyles.value]
      }, {
        default: () => [hasImage && createVNode("div", {
          "class": "v-app-bar__image"
        }, [slots.image ? (_slots$img = slots.img) == null ? void 0 : _slots$img.call(slots, {
          src: props.image
        }) : createVNode(VImg_default, {
          "src": props.image,
          "cover": true
        }, null, 8, ["src", "cover"])]), createVNode("div", {
          "class": "v-app-bar__content",
          "style": {
            height: convertToUnit(contentHeight.value)
          }
        }, [slots.prepend && createVNode("div", {
          "class": "v-app-bar__prepend"
        }, [slots.prepend()]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), slots.append && createVNode("div", {
          "class": "v-app-bar__append"
        }, [slots.append()])], 4), isExtended && createVNode("div", {
          "class": "v-app-bar__extension",
          "style": {
            height: convertToUnit(props.extensionHeight)
          }
        }, [(_slots$extension = slots.extension) == null ? void 0 : _slots$extension.call(slots)], 4)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/composables/icons.mjs
var IconSymbol = Symbol.for("vuetify:icons");
var makeIconProps = propsFactory({
  icon: {
    type: [String, Object],
    required: true
  },
  tag: {
    type: String,
    required: true
  }
}, "icon");
var VComponentIcon = defineComponent2({
  name: "VComponentIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, null, {
        default: () => [createVNode(props.icon, null, null)]
      });
    };
  }
});
var VSvgIcon = defineComponent2({
  name: "VSvgIcon",
  inheritAttrs: false,
  props: makeIconProps(),
  setup(props, {
    attrs
  }) {
    return () => {
      return createVNode(props.tag, mergeProps(attrs, {
        "style": null
      }), {
        default: () => [createVNode("svg", {
          "class": "v-icon__svg",
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": "0 0 24 24",
          "role": "img",
          "aria-hidden": "true"
        }, [createVNode("path", {
          "d": props.icon
        }, null, 8, ["d"])])]
      }, 16);
    };
  }
});
var VLigatureIcon = defineComponent2({
  name: "VLigatureIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, null, {
        default: () => [props.icon]
      });
    };
  }
});
var VClassIcon = defineComponent2({
  name: "VClassIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, {
        "class": props.icon
      }, null, 8, ["class"]);
    };
  }
});
var defaultSets = {
  svg: {
    component: VSvgIcon
  },
  class: {
    component: VClassIcon
  }
};
var useIcon = (props) => {
  const icons = inject(IconSymbol);
  if (!icons)
    throw new Error("Missing Vuetify Icons provide!");
  const iconData = computed(() => {
    const iconAlias = isRef(props) ? props.value : props.icon;
    if (!iconAlias)
      throw new Error("Icon value is undefined or null");
    let icon = iconAlias;
    if (typeof iconAlias === "string" && iconAlias.includes("$")) {
      var _icons$aliases;
      icon = (_icons$aliases = icons.aliases) == null ? void 0 : _icons$aliases[iconAlias.slice(iconAlias.indexOf("$") + 1)];
    }
    if (!icon)
      throw new Error(`Could not find aliased icon "${iconAlias}"`);
    if (typeof icon !== "string") {
      return {
        component: VComponentIcon,
        icon
      };
    }
    const hasSet = icon.includes(":");
    const setName = hasSet ? icon.split(":")[0] : icons.defaultSet;
    const iconName = hasSet ? icon.split(":")[1] : icon;
    const set = icons.sets[setName != null ? setName : icons.defaultSet];
    if (!set) {
      throw new Error(`Could not find icon set "${setName}"`);
    }
    return {
      component: set.component,
      icon: iconName
    };
  });
  return {
    iconData
  };
};

// node_modules/vuetify/lib/components/VIcon/VIcon.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VIcon/VIcon.sass";

// node_modules/vuetify/lib/composables/size.mjs
var predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
var makeSizeProps = propsFactory({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function useSize(props, name) {
  const sizeClasses = computed(() => {
    return predefinedSizes.includes(props.size) ? `${name}--size-${props.size}` : null;
  });
  const sizeStyles = computed(() => {
    return !predefinedSizes.includes(props.size) && props.size ? {
      width: convertToUnit(props.size),
      height: convertToUnit(props.size)
    } : null;
  });
  return {
    sizeClasses,
    sizeStyles
  };
}

// node_modules/vuetify/lib/components/VIcon/VIcon.mjs
var VIcon_default = defineComponent2({
  name: "VIcon",
  props: {
    color: String,
    left: Boolean,
    right: Boolean,
    icon: {
      type: [String, Object]
    },
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "i"
    })
  },
  setup(props, {
    slots
  }) {
    let slotIcon;
    if (slots.default) {
      slotIcon = computed(() => {
        var _slots$default, _flattenFragments$fil;
        const slot = (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
        if (!slot)
          return;
        return (_flattenFragments$fil = flattenFragments(slot).filter((node) => node.children && typeof node.children === "string")[0]) == null ? void 0 : _flattenFragments$fil.children;
      });
    }
    const {
      iconData
    } = useIcon(slotIcon || props);
    const {
      sizeClasses
    } = useSize(props, "v-icon");
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    return () => {
      return createVNode(iconData.value.component, {
        "tag": props.tag,
        "icon": iconData.value.icon,
        "class": ["v-icon", "notranslate", sizeClasses.value, textColorClasses.value, {
          "v-icon--left": props.left,
          "v-icon--right": props.right
        }],
        "style": [!sizeClasses.value ? {
          fontSize: convertToUnit(props.size),
          width: convertToUnit(props.size),
          height: convertToUnit(props.size)
        } : void 0, textColorStyles.value],
        "aria-hidden": "true"
      }, null, 8, ["tag", "icon", "class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VBtn/VBtn.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VBtn/VBtn.sass";

// node_modules/vuetify/lib/composables/position.mjs
var positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
var makePositionProps = propsFactory({
  absolute: Boolean,
  bottom: [Boolean, Number, String],
  fixed: Boolean,
  left: [Boolean, Number, String],
  position: {
    type: String,
    validator: (v) => positionValues.includes(v)
  },
  right: [Boolean, Number, String],
  top: [Boolean, Number, String]
}, "position");
function usePosition(props, name) {
  const targets = ["top", "right", "bottom", "left"];
  const positionClasses = computed(() => {
    if (props.fixed)
      return `${name}--fixed`;
    if (props.absolute)
      return `${name}--absolute`;
    return props.position ? `position-${props.position}` : void 0;
  });
  const positionStyles = computed(() => {
    const styles = {};
    for (const target of targets) {
      const prop = props[target];
      if (prop == null || prop === false)
        continue;
      styles[target] = convertToUnit(prop === true ? "0" : String(prop));
    }
    return styles;
  });
  return {
    positionClasses,
    positionStyles
  };
}

// node_modules/vuetify/lib/composables/router.mjs
function useRouter() {
  var _getCurrentInstance, _getCurrentInstance$p;
  return (_getCurrentInstance = getCurrentInstance()) == null ? void 0 : (_getCurrentInstance$p = _getCurrentInstance.proxy) == null ? void 0 : _getCurrentInstance$p.$router;
}
function useLink(props, attrs) {
  const RouterLink = resolveDynamicComponent("RouterLink");
  const isLink = computed(() => !!(props.href || props.to));
  const isClickable = computed(() => {
    return (isLink == null ? void 0 : isLink.value) || !!(attrs.onClick || attrs.onClickOnce);
  });
  if (typeof RouterLink === "string") {
    return {
      isLink,
      isClickable,
      href: toRef(props, "href")
    };
  }
  const link = props.to ? RouterLink.useLink(props) : void 0;
  return {
    ...link,
    isLink,
    isClickable,
    href: computed(() => props.to ? link == null ? void 0 : link.route.value.href : props.href)
  };
}
var makeRouterProps = propsFactory({
  href: String,
  replace: Boolean,
  to: [String, Object]
}, "router");
function useBackButton(cb) {
  const router = useRouter();
  let popped = false;
  let removeGuard;
  onMounted(() => {
    window.addEventListener("popstate", onPopstate);
    removeGuard = router == null ? void 0 : router.beforeEach((to, from, next) => {
      setTimeout(() => popped ? cb(next) : next());
    });
  });
  onBeforeUnmount(() => {
    var _removeGuard;
    window.removeEventListener("popstate", onPopstate);
    (_removeGuard = removeGuard) == null ? void 0 : _removeGuard();
  });
  function onPopstate(e) {
    if (e.state.replaced)
      return;
    popped = true;
    setTimeout(() => popped = false);
  }
}

// node_modules/vuetify/lib/composables/variant.mjs
var allowedVariants = ["contained", "outlined", "plain", "text", "contained-text"];
function genOverlays(isClickable, name) {
  return createVNode(Fragment, null, [isClickable && createVNode("div", {
    "class": `${name}__overlay`
  }, null), createVNode("div", {
    "class": `${name}__underlay`
  }, null)]);
}
var makeVariantProps = propsFactory({
  color: String,
  textColor: String,
  variant: {
    type: String,
    default: "contained",
    validator: (v) => allowedVariants.includes(v)
  }
}, "variant");
function useVariant(props, name) {
  const variantClasses = computed(() => {
    const {
      variant
    } = unref(props);
    return `${name}--variant-${variant}`;
  });
  const {
    colorClasses,
    colorStyles
  } = useColor(computed(() => {
    const {
      textColor,
      variant,
      color
    } = unref(props);
    return {
      text: textColor,
      [variant === "contained" ? "background" : "text"]: color
    };
  }));
  return {
    colorClasses,
    colorStyles,
    variantClasses
  };
}

// node_modules/vuetify/lib/components/VBtn/VBtn.mjs
var VBtn_default = defineComponent2({
  name: "VBtn",
  directives: {
    Ripple
  },
  props: {
    flat: Boolean,
    icon: [Boolean, String],
    prependIcon: String,
    appendIcon: String,
    block: Boolean,
    stacked: Boolean,
    disabled: Boolean,
    ripple: {
      type: Boolean,
      default: true
    },
    ...makeBorderProps(),
    ...makeRoundedProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRouterProps(),
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "button"
    }),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "contained"
    })
  },
  setup(props, {
    attrs,
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-btn");
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props, "v-btn");
    const {
      densityClasses
    } = useDensity(props, "v-btn");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, "v-btn");
    const {
      roundedClasses
    } = useRounded(props, "v-btn");
    const {
      sizeClasses
    } = useSize(props, "v-btn");
    const link = useLink(props, attrs);
    const isElevated = computed(() => {
      return props.variant === "contained" && !(props.disabled || props.flat || props.border);
    });
    return () => {
      var _link$isExactActive, _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      return withDirectives(createVNode(Tag, {
        "type": Tag === "a" ? void 0 : "button",
        "class": ["v-btn", {
          "v-btn--active": (_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value,
          "v-btn--block": props.block,
          "v-btn--disabled": props.disabled,
          "v-btn--elevated": isElevated.value,
          "v-btn--icon": !!props.icon,
          "v-btn--stacked": props.stacked
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value, positionStyles.value],
        "disabled": props.disabled || void 0,
        "href": link.href.value,
        "onClick": props.disabled || link.navigate
      }, {
        default: () => [genOverlays(true, "v-btn"), !props.icon && props.prependIcon && createVNode(VIcon_default, {
          "class": "v-btn__icon",
          "icon": props.prependIcon,
          "left": !props.stacked
        }, null, 8, ["icon", "left"]), typeof props.icon === "boolean" ? (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots) : createVNode(VIcon_default, {
          "class": "v-btn__icon",
          "icon": props.icon,
          "size": props.size
        }, null, 8, ["icon", "size"]), !props.icon && props.appendIcon && createVNode(VIcon_default, {
          "class": "v-btn__icon",
          "icon": props.appendIcon,
          "right": !props.stacked
        }, null, 8, ["icon", "right"])],
        _: 1
      }, 8, ["type", "class", "style", "disabled", "href", "onClick"]), [[resolveDirective("ripple"), !props.disabled && props.ripple, null]]);
    };
  }
});

// node_modules/vuetify/lib/components/VAppBar/VAppBarNavIcon.mjs
var VAppBarNavIcon_default = defineComponent2({
  name: "VAppBarNavIcon",
  props: {
    icon: {
      type: String,
      default: "$menu"
    }
  },
  setup(props, {
    slots
  }) {
    return () => {
      var _slots$default;
      return createVNode(VBtn_default, {
        "class": "v-app-bar-nav-icon",
        "icon": props.icon
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
      }, 8, ["icon"]);
    };
  }
});

// node_modules/vuetify/lib/components/VAppBar/VAppBarTitle.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VAppBar/VAppBarTitle.sass";
var VAppBarTitle_default = defineComponent2({
  name: "VAppBarTitle",
  props: {
    ...makeTagProps({
      tag: "header"
    })
  },
  setup(props, {
    slots
  }) {
    return () => createVNode(props.tag, {
      "class": "v-app-bar-title"
    }, {
      default: () => [slots.default && createVNode("div", {
        "class": "v-app-bar-title__placeholder"
      }, [slots.default()])]
    });
  }
});

// node_modules/vuetify/lib/components/VAvatar/VAvatar.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VAvatar/VAvatar.sass";
var VAvatar_default = defineComponent2({
  name: "VAvatar",
  props: {
    color: String,
    left: Boolean,
    right: Boolean,
    icon: String,
    image: String,
    ...makeDensityProps(),
    ...makeRoundedProps(),
    ...makeSizeProps(),
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      densityClasses
    } = useDensity(props, "v-avatar");
    const {
      roundedClasses
    } = useRounded(props, "v-avatar");
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props, "v-avatar");
    return () => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-avatar", {
          "v-avatar--left": props.left,
          "v-avatar--right": props.right
        }, backgroundColorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value],
        "style": [backgroundColorStyles.value, sizeStyles.value]
      }, {
        default: () => [props.image && createVNode(VImg_default, {
          "src": props.image,
          "alt": ""
        }, null, 8, ["src"]), props.icon && !props.image && createVNode(VIcon_default, {
          "icon": props.icon
        }, null, 8, ["icon"]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VAlert/VAlert.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VAlert/VAlert.sass";
var allowedTypes = ["success", "info", "warning", "error"];
var VAlert_default = defineComponent2({
  name: "VAlert",
  props: {
    border: {
      type: [Boolean, String],
      validator: (val) => {
        return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
      }
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
      type: String,
      default: "$close"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    icon: {
      type: [Boolean, String],
      default: null
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    prominent: Boolean,
    sticky: Boolean,
    text: String,
    tip: Boolean,
    type: {
      type: String,
      validator: (val) => allowedTypes.includes(val)
    },
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps()
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, {
    slots
  }) {
    const borderProps = computed(() => ({
      border: props.border === true || props.tip ? "start" : props.border
    }));
    const isActive = useProxiedModel(props, "modelValue");
    const icon = computed(() => {
      var _props$icon;
      if (props.icon === false)
        return void 0;
      if (!props.type)
        return props.icon;
      return (_props$icon = props.icon) != null ? _props$icon : `$${props.type}`;
    });
    const variantProps = computed(() => {
      var _props$color;
      return {
        color: (_props$color = props.color) != null ? _props$color : props.type,
        textColor: props.textColor,
        variant: props.variant
      };
    });
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(borderProps.value, "v-alert");
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps, "v-alert");
    const {
      densityClasses
    } = useDensity(props, "v-alert");
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, "v-alert");
    const {
      roundedClasses
    } = useRounded(props, "v-alert");
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => {
      var _props$borderColor;
      return (_props$borderColor = props.borderColor) != null ? _props$borderColor : props.tip ? variantProps.value.color : void 0;
    }));
    function onCloseClick(e) {
      isActive.value = false;
    }
    return () => {
      const hasBorder = !!borderProps.value.border;
      const hasClose = !!(slots.close || props.closable);
      const hasPrepend = !!(slots.prepend || props.icon || props.type);
      const hasText = !!(slots.default || props.text || hasClose);
      return isActive.value && createVNode(props.tag, {
        "class": ["v-alert", {
          [`v-alert--border-${borderProps.value.border}`]: hasBorder,
          "v-alert--prominent": props.prominent,
          "v-alert--tip": props.tip
        }, themeClasses.value, borderClasses.value, !props.tip && colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value],
        "style": [!props.tip && colorStyles.value, positionStyles.value],
        "role": "alert"
      }, {
        default: () => [hasBorder && createVNode("div", {
          "class": ["v-alert__border", textColorClasses.value],
          "style": textColorStyles.value
        }, null, 6), createVNode("div", {
          "class": "v-alert__underlay"
        }, null), createVNode("div", {
          "class": "v-alert__content"
        }, [hasPrepend && createVNode("div", {
          "class": "v-alert__avatar"
        }, [slots.prepend ? slots.prepend() : createVNode(VAvatar_default, {
          "class": props.tip && textColorClasses.value,
          "style": props.tip && textColorStyles.value,
          "density": props.density,
          "icon": icon.value
        }, null, 8, ["class", "style", "density", "icon"])]), hasText && createVNode("div", {
          "class": "v-alert__text"
        }, [slots.default ? slots.default() : props.text, hasClose && createVNode("div", {
          "class": "v-alert__close"
        }, [slots.close ? slots.close({
          props: {
            onClick: onCloseClick
          }
        }) : createVNode(VBtn_default, {
          "density": props.density,
          "icon": props.closeIcon,
          "variant": "text",
          "onClick": onCloseClick
        }, null, 8, ["density", "icon", "onClick"])])])])],
        _: 1
      }, 8, ["class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VBadge/VBadge.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VBadge/VBadge.sass";
var VBadge_default = defineComponent2({
  name: "VBadge",
  inheritAttrs: false,
  props: {
    bordered: Boolean,
    color: {
      type: String,
      default: "primary"
    },
    content: String,
    dot: Boolean,
    floating: Boolean,
    icon: String,
    inline: Boolean,
    label: {
      type: String,
      default: "$vuetify.badge"
    },
    location: {
      type: String,
      default: "top-right",
      validator: (value) => {
        const [vertical, horizontal] = (value != null ? value : "").split("-");
        return ["top", "bottom"].includes(vertical) && ["left", "right"].includes(horizontal);
      }
    },
    max: [Number, String],
    modelValue: {
      type: Boolean,
      default: true
    },
    offsetX: [Number, String],
    offsetY: [Number, String],
    textColor: String,
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeTransitionProps({
      transition: "scale-rotate-transition"
    })
  },
  setup(props, ctx) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      roundedClasses
    } = useRounded(props, "v-badge");
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "textColor"));
    const position = computed(() => {
      return props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
    });
    function calculatePosition(offset) {
      return `calc(100% - ${convertToUnit(position.value + parseInt(offset != null ? offset : 0, 10))})`;
    }
    const locationStyles = computed(() => {
      var _props$location;
      const [vertical, horizontal] = ((_props$location = props.location) != null ? _props$location : "").split("-");
      const styles = {
        bottom: "auto",
        left: "auto",
        right: "auto",
        top: "auto"
      };
      if (!props.inline) {
        styles[horizontal === "left" ? "right" : "left"] = calculatePosition(props.offsetX);
        styles[vertical === "top" ? "bottom" : "top"] = calculatePosition(props.offsetY);
      }
      return styles;
    });
    return () => {
      var _ctx$slots$default, _ctx$slots, _ctx$slots$badge, _ctx$slots2;
      const value = Number(props.content);
      const content = !props.max || isNaN(value) ? props.content : value <= props.max ? value : `${props.max}+`;
      const [badgeAttrs, attrs] = extract(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return createVNode(props.tag, mergeProps({
        "class": ["v-badge", {
          "v-badge--bordered": props.bordered,
          "v-badge--dot": props.dot,
          "v-badge--floating": props.floating,
          "v-badge--inline": props.inline
        }]
      }, attrs), {
        default: () => [createVNode("div", {
          "class": "v-badge__wrapper"
        }, [(_ctx$slots$default = (_ctx$slots = ctx.slots).default) == null ? void 0 : _ctx$slots$default.call(_ctx$slots), createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [withDirectives(createVNode("span", mergeProps({
            "class": ["v-badge__badge", backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
            "style": [backgroundColorStyles.value, locationStyles.value, textColorStyles.value],
            "aria-atomic": "true",
            "aria-label": "locale string here",
            "aria-live": "polite",
            "role": "status"
          }, badgeAttrs), [props.dot ? void 0 : ctx.slots.badge ? (_ctx$slots$badge = (_ctx$slots2 = ctx.slots).badge) == null ? void 0 : _ctx$slots$badge.call(_ctx$slots2) : props.icon ? createVNode(VIcon_default, {
            "icon": props.icon
          }, null, 8, ["icon"]) : createVNode("span", {
            "class": "v-badge__content"
          }, [content])], 16), [[vShow, props.modelValue]])]
        }, 8, ["transition"])])]
      }, 16, ["class"]);
    };
  }
});

// node_modules/vuetify/lib/components/VBanner/VBannerActions.mjs
var VBannerActions_default = createSimpleFunctional("v-banner-actions");

// node_modules/vuetify/lib/components/VBanner/VBannerAvatar.mjs
var VBannerAvatar_default = defineComponent2({
  name: "VBannerAvatar",
  props: {
    left: Boolean,
    right: Boolean,
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    return () => {
      return createVNode(props.tag, {
        "class": ["v-banner-avatar", {
          "v-banner-avatar--start": props.left,
          "v-banner-avatar--end": props.right
        }]
      }, slots, 8, ["class"]);
    };
  }
});

// node_modules/vuetify/lib/components/VBanner/VBannerContent.mjs
var VBannerContent_default = createSimpleFunctional("v-banner-content");

// node_modules/vuetify/lib/components/VBanner/VBannerText.mjs
var VBannerText_default = createSimpleFunctional("v-banner-text");

// node_modules/vuetify/lib/components/VBanner/VBanner.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VBanner/VBanner.sass";

// node_modules/vuetify/lib/composables/display.mjs
var DisplaySymbol = Symbol.for("vuetify:display");
var defaultDisplayOptions = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
};
var parseDisplayOptions = (options = defaultDisplayOptions) => {
  return mergeDeep(defaultDisplayOptions, options);
};
function getClientWidth() {
  return IN_BROWSER ? Math.max(document.documentElement.clientWidth, window.innerWidth) : 0;
}
function getClientHeight() {
  return IN_BROWSER ? Math.max(document.documentElement.clientHeight, window.innerHeight) : 0;
}
function getPlatform() {
  const userAgent = IN_BROWSER ? window.navigator.userAgent : "ssr";
  function match(regexp) {
    return Boolean(userAgent.match(regexp));
  }
  const android = match(/android/i);
  const ios = match(/iphone|ipad|ipod/i);
  const cordova = match(/cordova/i);
  const electron = match(/electron/i);
  const chrome = match(/chrome/i);
  const edge = match(/edge/i);
  const firefox = match(/firefox/i);
  const opera = match(/opera/i);
  const win = match(/win/i);
  const mac = match(/mac/i);
  const linux = match(/linux/i);
  const ssr = match(/ssr/i);
  return {
    android,
    ios,
    cordova,
    electron,
    chrome,
    edge,
    firefox,
    opera,
    win,
    mac,
    linux,
    touch: SUPPORTS_TOUCH,
    ssr
  };
}
function createDisplay(options) {
  const {
    thresholds,
    mobileBreakpoint
  } = parseDisplayOptions(options);
  const height = ref(getClientHeight());
  const platform = getPlatform();
  const state = reactive({});
  const width = ref(getClientWidth());
  function onResize() {
    height.value = getClientHeight();
    width.value = getClientWidth();
  }
  watchEffect(() => {
    const xs = width.value < thresholds.sm;
    const sm = width.value < thresholds.md && !xs;
    const md = width.value < thresholds.lg && !(sm || xs);
    const lg = width.value < thresholds.xl && !(md || sm || xs);
    const xl = width.value < thresholds.xxl && !(lg || md || sm || xs);
    const xxl = width.value >= thresholds.xxl;
    const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : "xxl";
    const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
    const mobile = !platform.ssr ? width.value < breakpointValue : platform.android || platform.ios || platform.opera;
    state.xs = xs;
    state.sm = sm;
    state.md = md;
    state.lg = lg;
    state.xl = xl;
    state.xxl = xxl;
    state.smAndUp = !xs;
    state.mdAndUp = !(xs || sm);
    state.lgAndUp = !(xs || sm || md);
    state.xlAndUp = !(xs || sm || md || lg);
    state.smAndDown = !(md || lg || xl || xxl);
    state.mdAndDown = !(lg || xl || xxl);
    state.lgAndDown = !(xl || xxl);
    state.xlAndDown = !xxl;
    state.name = name;
    state.height = height.value;
    state.width = width.value;
    state.mobile = mobile;
    state.mobileBreakpoint = mobileBreakpoint;
    state.platform = platform;
    state.thresholds = thresholds;
  });
  if (IN_BROWSER) {
    window.addEventListener("resize", onResize, {
      passive: true
    });
  }
  return toRefs(state);
}
function useDisplay() {
  const display = inject(DisplaySymbol);
  if (!display)
    throw new Error("Could not find Vuetify display injection");
  return display;
}

// node_modules/vuetify/lib/components/VBanner/VBanner.mjs
var VBanner_default = defineComponent2({
  name: "VBanner",
  props: {
    avatar: String,
    color: String,
    icon: String,
    lines: {
      type: String,
      default: "one"
    },
    sticky: Boolean,
    text: String,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-banner");
    const {
      densityClasses
    } = useDensity(props, "v-banner");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      mobile
    } = useDisplay();
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, "v-banner");
    const {
      roundedClasses
    } = useRounded(props, "v-banner");
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    return () => {
      var _slots$default;
      const hasAvatar = !!(props.avatar || props.icon || slots.avatar || slots.icon);
      const hasText = !!(props.text || slots.text);
      const hasContent = hasAvatar || hasText || slots.default;
      return createVNode(props.tag, {
        "class": ["v-banner", {
          "v-banner--mobile": mobile.value,
          "v-banner--sticky": props.sticky,
          [`v-banner--${props.lines}-line`]: true
        }, borderClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, textColorClasses.value, themeClasses.value],
        "style": [dimensionStyles.value, positionStyles.value, textColorStyles.value],
        "role": "banner"
      }, {
        default: () => [hasContent && createVNode(VBannerContent_default, null, {
          default: () => [hasAvatar && createVNode(VBannerAvatar_default, null, {
            default: () => [slots.avatar ? slots.avatar() : createVNode(VAvatar_default, {
              "density": props.density,
              "icon": props.icon,
              "image": props.avatar
            }, null, 8, ["density", "icon", "image"])]
          }), hasText && createVNode(VBannerText_default, null, {
            default: () => [slots.text ? slots.text() : props.text]
          }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
          _: 1
        }), slots.actions && createVNode(VBannerActions_default, null, {
          default: slots.actions
        })],
        _: 1
      }, 8, ["class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VBottomNavigation/VBottomNavigation.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VBottomNavigation/VBottomNavigation.sass";
var VBottomNavigation_default = defineComponent2({
  name: "VBottomNavigation",
  props: {
    bgColor: String,
    color: String,
    grow: Boolean,
    modelValue: {
      type: Boolean,
      default: true
    },
    mode: {
      type: String,
      validator: (v) => !v || ["horizontal", "shift"].includes(v)
    },
    height: {
      type: [Number, String],
      default: 56
    },
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeLayoutItemProps({
      name: "bottom-navigation"
    }),
    ...makeTagProps({
      tag: "header"
    }),
    ...makeThemeProps()
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-bottom-navigation");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(computed(() => props.bgColor));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => props.color));
    const {
      densityClasses
    } = useDensity(props, "v-bottom-navigation");
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, "v-bottom-navigation");
    const height = computed(() => Number(props.height) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0));
    const isActive = useProxiedModel(props, "modelValue", props.modelValue);
    const layoutStyles = useLayoutItem(props.name, computed(() => props.priority), computed(() => "bottom"), computed(() => isActive.value ? height.value : 0), height, isActive);
    return () => {
      return createVNode(props.tag, {
        "class": ["v-bottom-navigation", {
          "v-bottom-navigation--grow": props.grow,
          "v-bottom-navigation--horizontal": props.mode === "horizontal",
          "v-bottom-navigation--is-active": isActive.value,
          "v-bottom-navigation--shift": props.mode === "shift",
          "v-bottom-navigation--absolute": props.absolute
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, textColorClasses.value],
        "style": [backgroundColorStyles.value, layoutStyles.value, textColorStyles.value, {
          height: convertToUnit(height.value),
          transform: `translateY(${convertToUnit(!isActive.value ? 100 : 0, "%")})`
        }]
      }, {
        default: () => [slots.default && createVNode("div", {
          "class": "v-bottom-navigation__content"
        }, [slots.default()])]
      }, 8, ["class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VBreadcrumbs/shared.mjs
var VBreadcrumbsSymbol = Symbol.for("vuetify:breadcrumbs");

// node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsItem.mjs
var VBreadcrumbsItem_default = defineComponent2({
  name: "VBreadcrumbsItem",
  props: {
    active: Boolean,
    activeClass: String,
    activeColor: String,
    color: String,
    disabled: Boolean,
    text: String,
    ...makeRouterProps(),
    ...makeTagProps({
      tag: "li"
    })
  },
  setup(props, {
    slots,
    attrs
  }) {
    const breadcrumbs = inject(VBreadcrumbsSymbol);
    if (!breadcrumbs)
      throw new Error("[Vuetify] Could not find v-breadcrumbs provider");
    const link = useLink(props, attrs);
    const isActive = computed(() => {
      var _link$isExactActive;
      return props.active || ((_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value);
    });
    const color = computed(() => {
      var _props$activeColor;
      if (isActive.value)
        return (_props$activeColor = props.activeColor) != null ? _props$activeColor : breadcrumbs.color.value;
      return props.color;
    });
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    return () => {
      var _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      return createVNode(Tag, {
        "class": ["v-breadcrumbs-item", {
          "v-breadcrumbs-item--active": isActive.value,
          "v-breadcrumbs-item--disabled": props.disabled || breadcrumbs.disabled.value,
          "v-breadcrumbs-item--link": link.isLink.value,
          [`${props.activeClass}`]: isActive.value && props.activeClass
        }, textColorClasses.value],
        "style": [textColorStyles.value],
        "aria-current": isActive.value ? "page" : void 0,
        "onClick": isActive.value && link.navigate
      }, {
        default: () => [props.text, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style", "aria-current", "onClick"]);
    };
  }
});

// node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsDivider.mjs
var VBreadcrumbsDivider_default = createSimpleFunctional("v-breadcrumbs-divider", "li");

// node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.sass";
var VBreadcrumbs_default = defineComponent2({
  name: "VBreadcrumbs",
  props: {
    color: String,
    disabled: Boolean,
    divider: {
      type: String,
      default: "/"
    },
    icon: String,
    items: {
      type: Array,
      default: () => []
    },
    ...makeDensityProps(),
    ...makeRoundedProps(),
    ...makeTagProps({
      tag: "ul"
    })
  },
  setup(props, {
    slots
  }) {
    const {
      densityClasses
    } = useDensity(props, "v-breadcrumbs");
    const {
      roundedClasses
    } = useRounded(props, "v-breadcrumbs");
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    const items = computed(() => {
      return props.items.map((item, index, array) => ({
        props: {
          disabled: index >= array.length - 1,
          ...typeof item === "string" ? {
            text: item
          } : item
        }
      }));
    });
    provide(VBreadcrumbsSymbol, {
      color: toRef(props, "color"),
      disabled: toRef(props, "disabled")
    });
    return () => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-breadcrumbs", densityClasses.value, roundedClasses.value, textColorClasses.value],
        "style": [textColorStyles.value]
      }, {
        default: () => [props.icon && createVNode(VIcon_default, {
          "icon": props.icon,
          "left": true
        }, null, 8, ["icon", "left"]), items.value.map((item, index) => {
          var _slots$item;
          return createVNode(Fragment, null, [createVNode(VBreadcrumbsItem_default, mergeProps({
            "key": index
          }, item.props), {
            default: () => [(_slots$item = slots.item) == null ? void 0 : _slots$item.call(slots, {
              ...item,
              index
            })]
          }, 16), index < props.items.length - 1 && createVNode(VBreadcrumbsDivider_default, null, {
            default: () => [slots.divider ? slots.divider({
              ...item,
              index
            }) : props.divider]
          })]);
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VCard/VCardActions.mjs
var VCardActions_default = createSimpleFunctional("v-card-actions");

// node_modules/vuetify/lib/components/VCard/VCardAvatar.mjs
var VCardAvatar_default = createSimpleFunctional("v-card-avatar");

// node_modules/vuetify/lib/components/VCard/VCardHeader.mjs
var VCardHeader_default = createSimpleFunctional("v-card-header");

// node_modules/vuetify/lib/components/VCard/VCardHeaderText.mjs
var VCardHeaderText_default = createSimpleFunctional("v-card-header-text");

// node_modules/vuetify/lib/components/VCard/VCardImg.mjs
var VCardImg_default = createSimpleFunctional("v-card-img");

// node_modules/vuetify/lib/components/VCard/VCardSubtitle.mjs
var VCardSubtitle_default = createSimpleFunctional("v-card-subtitle");

// node_modules/vuetify/lib/components/VCard/VCardText.mjs
var VCardText_default = createSimpleFunctional("v-card-text");

// node_modules/vuetify/lib/components/VCard/VCardTitle.mjs
var VCardTitle_default = createSimpleFunctional("v-card-title");

// node_modules/vuetify/lib/components/VCard/VCard.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VCard/VCard.sass";
var VCard_default = defineComponent2({
  name: "VCard",
  directives: {
    Ripple
  },
  props: {
    appendAvatar: String,
    appendIcon: String,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: Boolean,
    prependAvatar: String,
    prependIcon: String,
    ripple: Boolean,
    subtitle: String,
    text: String,
    title: String,
    ...makeThemeProps(),
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeTagProps(),
    ...makeVariantProps({
      variant: "contained"
    })
  },
  setup(props, {
    attrs,
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-card");
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props, "v-card");
    const {
      densityClasses
    } = useDensity(props, "v-card");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, "v-card");
    const {
      roundedClasses
    } = useRounded(props, "v-card");
    const link = useLink(props, attrs);
    return () => {
      var _slots$image, _slots$media, _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasTitle = !!(slots.title || props.title);
      const hasSubtitle = !!(slots.subtitle || props.subtitle);
      const hasHeaderText = hasTitle || hasSubtitle;
      const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
      const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
      const hasImage = !!(slots.image || props.image);
      const hasHeader = hasHeaderText || hasPrepend || hasAppend;
      const hasText = !!(slots.text || props.text);
      const isClickable = !props.disabled && (link.isClickable.value || props.link);
      return withDirectives(createVNode(Tag, {
        "class": ["v-card", {
          "v-card--disabled": props.disabled,
          "v-card--flat": props.flat,
          "v-card--hover": props.hover && !(props.disabled || props.flat),
          "v-card--link": isClickable
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value, positionStyles.value],
        "href": link.href.value,
        "onClick": isClickable && link.navigate
      }, {
        default: () => [genOverlays(isClickable, "v-card"), hasImage && createVNode(VCardImg_default, null, {
          default: () => [slots.image ? (_slots$image = slots.image) == null ? void 0 : _slots$image.call(slots, {
            src: props.image
          }) : createVNode(VImg_default, {
            "src": props.image,
            "cover": true,
            "alt": ""
          }, null, 8, ["src", "cover"])]
        }), (_slots$media = slots.media) == null ? void 0 : _slots$media.call(slots), hasHeader && createVNode(VCardHeader_default, null, {
          default: () => [hasPrepend && createVNode(VCardAvatar_default, null, {
            default: () => [slots.prepend ? slots.prepend() : createVNode(VAvatar_default, {
              "density": props.density,
              "icon": props.prependIcon,
              "image": props.prependAvatar
            }, null, 8, ["density", "icon", "image"])]
          }), hasHeaderText && createVNode(VCardHeaderText_default, null, {
            default: () => [hasTitle && createVNode(VCardTitle_default, null, {
              default: () => [slots.title ? slots.title() : props.title]
            }), createVNode(VCardSubtitle_default, null, {
              default: () => [slots.subtitle ? slots.subtitle() : props.subtitle]
            })],
            _: 1
          }), hasAppend && createVNode(VCardAvatar_default, null, {
            default: () => [slots.append ? slots.append() : createVNode(VAvatar_default, {
              "density": props.density,
              "icon": props.appendIcon,
              "image": props.appendAvatar
            }, null, 8, ["density", "icon", "image"])]
          })],
          _: 1
        }), hasText && createVNode(VCardText_default, null, {
          default: () => [slots.text ? slots.text() : props.text]
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), slots.actions && createVNode(VCardActions_default, null, {
          default: slots.actions
        })],
        _: 1
      }, 8, ["class", "style", "href", "onClick"]), [[resolveDirective("ripple"), isClickable]]);
    };
  }
});

// node_modules/vuetify/lib/components/VChip/VChip.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VChip/VChip.sass";
var VChip_default = defineComponent2({
  name: "VChip",
  directives: {
    Ripple
  },
  props: {
    activeClass: String,
    appendAvatar: String,
    appendIcon: String,
    closable: Boolean,
    closeIcon: {
      type: String,
      default: "$delete"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    disabled: Boolean,
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: "$complete"
    },
    label: Boolean,
    link: Boolean,
    pill: Boolean,
    prependAvatar: String,
    prependIcon: String,
    ripple: {
      type: Boolean,
      default: true
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "span"
    }),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "contained"
    })
  },
  emits: {
    "click:close": (e) => e,
    "update:active": (value) => value
  },
  setup(props, {
    attrs,
    emit,
    slots
  }) {
    const isActive = useProxiedModel(props, "modelValue");
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-chip");
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props, "v-chip");
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, "v-chip");
    const {
      sizeClasses
    } = useSize(props, "v-chip");
    const {
      densityClasses
    } = useDensity(props, "v-chip");
    const link = useLink(props, attrs);
    function onCloseClick(e) {
      isActive.value = false;
      emit("click:close", e);
    }
    return () => {
      var _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasAppend = !!(slots.append || props.appendIcon || props.appendAvatar);
      const hasClose = !!(slots.close || props.closable);
      const hasPrepend = !!(slots.prepend || props.prependIcon || props.prependAvatar);
      const isClickable = !props.disabled && (link.isClickable.value || props.link);
      return isActive.value && withDirectives(createVNode(Tag, {
        "class": ["v-chip", {
          "v-chip--disabled": props.disabled,
          "v-chip--label": props.label,
          "v-chip--link": isClickable,
          "v-chip--pill": props.pill
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value],
        "style": [colorStyles.value],
        "disabled": props.disabled || void 0,
        "draggable": props.draggable,
        "href": link.href.value,
        "onClick": isClickable && link.navigate
      }, {
        default: () => [genOverlays(isClickable, "v-chip"), hasPrepend && createVNode("div", {
          "class": "v-chip__prepend"
        }, [slots.prepend ? slots.prepend() : createVNode(VAvatar_default, {
          "icon": props.prependIcon,
          "image": props.prependAvatar,
          "size": props.size
        }, null, 8, ["icon", "image", "size"])]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), hasAppend && createVNode("div", {
          "class": "v-chip__append"
        }, [slots.append ? slots.append() : createVNode(VAvatar_default, {
          "icon": props.appendIcon,
          "image": props.appendAvatar,
          "size": props.size
        }, null, 8, ["icon", "image", "size"])]), hasClose && createVNode("div", {
          "class": "v-chip__close",
          "onClick": onCloseClick
        }, [slots.close ? slots.close({
          props: {
            onClick: onCloseClick
          }
        }) : createVNode(VIcon_default, {
          "icon": props.closeIcon,
          "size": "x-small"
        }, null, 8, ["icon"])], 8, ["onClick"])],
        _: 1
      }, 8, ["class", "style", "disabled", "draggable", "href", "onClick"]), [[resolveDirective("ripple"), isClickable && props.ripple, null]]);
    };
  }
});

// node_modules/vuetify/lib/components/VCode/index.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VCode/VCode.sass";
var VCode = createSimpleFunctional("v-code");

// node_modules/vuetify/lib/components/VDefaultsProvider/VDefaultsProvider.mjs
var VDefaultsProvider_default = defineComponent({
  props: {
    defaults: Object
  },
  setup(props, {
    slots
  }) {
    provideDefaults(props);
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
    };
  }
});

// node_modules/vuetify/lib/components/transitions/dialog-transition.mjs
var dialog_transition_default = defineComponent2({
  name: "VDialogTransition",
  props: {
    target: Object
  },
  setup(props, {
    slots
  }) {
    const functions = {
      onEnter(el, done) {
        const {
          x,
          y
        } = getDimensions(props.target, el);
        const animation = el.animate([{
          transform: `translate(${x}px, ${y}px) scale(0.1)`,
          opacity: 0
        }, {
          transform: ""
        }], {
          duration: 225,
          easing: deceleratedEasing
        });
        animation.finished.then(() => done());
      },
      onLeave(el, done) {
        const {
          x,
          y
        } = getDimensions(props.target, el);
        const animation = el.animate([{
          transform: ""
        }, {
          transform: `translate(${x}px, ${y}px) scale(0.1)`,
          opacity: 0
        }], {
          duration: 125,
          easing: acceleratedEasing
        });
        animation.finished.then(() => done());
      }
    };
    return () => {
      return props.target ? createVNode(Transition, mergeProps({
        "name": "dialog-transition"
      }, functions, {
        "css": false
      }), slots, 16) : createVNode(Transition, {
        "name": "dialog-transition"
      }, slots);
    };
  }
});
function getDimensions(target, el) {
  const initialDisplay = el.style.display;
  const initialTransform = el.style.transform;
  el.style.transition = "none";
  el.style.display = "";
  el.style.transform = "none";
  const targetBox = target.getBoundingClientRect();
  const elBox = el.getBoundingClientRect();
  const x = targetBox.width / 2 + targetBox.left - (elBox.width / 2 + elBox.left);
  const y = targetBox.height / 2 + targetBox.top - (elBox.height / 2 + elBox.top);
  el.style.display = initialDisplay;
  el.style.transform = initialTransform;
  return {
    x,
    y
  };
}

// node_modules/vuetify/lib/components/transitions/createTransition.mjs
function createCssTransition(name, origin = "top center 0", mode) {
  return defineComponent2({
    name,
    props: {
      group: Boolean,
      hideOnLeave: Boolean,
      leaveAbsolute: Boolean,
      mode: {
        type: String,
        default: mode
      },
      origin: {
        type: String,
        default: origin
      }
    },
    setup(props, {
      slots
    }) {
      return () => {
        const tag = props.group ? TransitionGroup : Transition;
        return h(tag, {
          name,
          mode: props.mode,
          onBeforeEnter(el) {
            el.style.transformOrigin = props.origin;
          },
          onLeave(el) {
            if (props.leaveAbsolute) {
              const {
                offsetTop,
                offsetLeft,
                offsetWidth,
                offsetHeight
              } = el;
              el._transitionInitialStyles = {
                position: el.style.position,
                top: el.style.top,
                left: el.style.left,
                width: el.style.width,
                height: el.style.height
              };
              el.style.position = "absolute";
              el.style.top = `${offsetTop}px`;
              el.style.left = `${offsetLeft}px`;
              el.style.width = `${offsetWidth}px`;
              el.style.height = `${offsetHeight}px`;
            }
            if (props.hideOnLeave) {
              el._initialDisplay = el.style.display;
              el.style.display = "none";
            }
          },
          onAfterLeave(el) {
            if (props.leaveAbsolute && el != null && el._transitionInitialStyles) {
              const {
                position,
                top,
                left,
                width,
                height
              } = el._transitionInitialStyles;
              delete el._transitionInitialStyles;
              el.style.position = position || "";
              el.style.top = top || "";
              el.style.left = left || "";
              el.style.width = width || "";
              el.style.height = height || "";
            }
            if (props.hideOnLeave && el) {
              el.style.display = el._initialDisplay || "";
            }
          }
        }, slots.default);
      };
    }
  });
}
function createJavascriptTransition(name, functions, mode = "in-out") {
  return defineComponent2({
    name,
    props: {
      mode: {
        type: String,
        default: mode
      }
    },
    setup(props, {
      slots
    }) {
      return () => {
        return h(Transition, {
          name,
          ...functions
        }, slots.default);
      };
    }
  });
}

// node_modules/vuetify/lib/components/transitions/expand-transition.mjs
function expand_transition_default(expandedParentClass = "", x = false) {
  const sizeProperty = x ? "width" : "height";
  const offsetProperty = camelize(`offset-${sizeProperty}`);
  return {
    onBeforeEnter(el) {
      el._parent = el.parentNode;
      el._initialStyle = {
        transition: el.style.transition,
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
    },
    onEnter(el) {
      const initialStyle = el._initialStyle;
      el.style.setProperty("transition", "none", "important");
      el.style.overflow = "hidden";
      const offset = `${el[offsetProperty]}px`;
      el.style[sizeProperty] = "0";
      void el.offsetHeight;
      el.style.transition = initialStyle.transition;
      if (expandedParentClass && el._parent) {
        el._parent.classList.add(expandedParentClass);
      }
      requestAnimationFrame(() => {
        el.style[sizeProperty] = offset;
      });
    },
    onAfterEnter: resetStyles,
    onEnterCancelled: resetStyles,
    onLeave(el) {
      el._initialStyle = {
        transition: "",
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
      el.style.overflow = "hidden";
      el.style[sizeProperty] = `${el[offsetProperty]}px`;
      void el.offsetHeight;
      requestAnimationFrame(() => el.style[sizeProperty] = "0");
    },
    onAfterLeave,
    onLeaveCancelled: onAfterLeave
  };
  function onAfterLeave(el) {
    if (expandedParentClass && el._parent) {
      el._parent.classList.remove(expandedParentClass);
    }
    resetStyles(el);
  }
  function resetStyles(el) {
    const size = el._initialStyle[sizeProperty];
    el.style.overflow = el._initialStyle.overflow;
    if (size != null)
      el.style[sizeProperty] = size;
    delete el._initialStyle;
  }
}

// node_modules/vuetify/lib/components/transitions/index.mjs
var VCarouselTransition = createCssTransition("carousel-transition");
var VCarouselReverseTransition = createCssTransition("carousel-reverse-transition");
var VTabTransition = createCssTransition("tab-transition");
var VTabReverseTransition = createCssTransition("tab-reverse-transition");
var VMenuTransition = createCssTransition("menu-transition");
var VFabTransition = createCssTransition("fab-transition", "center center", "out-in");
var VDialogBottomTransition = createCssTransition("dialog-bottom-transition");
var VDialogTopTransition = createCssTransition("dialog-top-transition");
var VFadeTransition = createCssTransition("fade-transition");
var VScaleTransition = createCssTransition("scale-transition");
var VScrollXTransition = createCssTransition("scroll-x-transition");
var VScrollXReverseTransition = createCssTransition("scroll-x-reverse-transition");
var VScrollYTransition = createCssTransition("scroll-y-transition");
var VScrollYReverseTransition = createCssTransition("scroll-y-reverse-transition");
var VSlideXTransition = createCssTransition("slide-x-transition");
var VSlideXReverseTransition = createCssTransition("slide-x-reverse-transition");
var VSlideYTransition = createCssTransition("slide-y-transition");
var VSlideYReverseTransition = createCssTransition("slide-y-reverse-transition");
var VExpandTransition = createJavascriptTransition("expand-transition", expand_transition_default());
var VExpandXTransition = createJavascriptTransition("expand-x-transition", expand_transition_default("", true));

// node_modules/vuetify/lib/components/VOverlay/VOverlay.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VOverlay/VOverlay.sass";

// node_modules/vuetify/lib/composables/teleport.mjs
function useTeleport(target) {
  const teleportTarget = computed(() => {
    const _target = target.value;
    if (_target === true)
      return void 0;
    const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
    if (targetElement == null) {
      warn(`Unable to locate target ${_target}`);
      return void 0;
    }
    if (!useTeleport.cache.has(targetElement)) {
      const el = document.createElement("div");
      el.className = "v-overlay-container";
      targetElement.appendChild(el);
      useTeleport.cache.set(targetElement, el);
    }
    return useTeleport.cache.get(targetElement);
  });
  return {
    teleportTarget
  };
}
useTeleport.cache = new WeakMap();

// node_modules/vuetify/lib/components/VOverlay/VOverlay.mjs
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function useBooted(isActive, eager) {
  const isBooted = ref(eager.value);
  watchEffect(() => {
    if (eager.value || isActive.value) {
      isBooted.value = true;
    }
  });
  return {
    isBooted
  };
}
var positionStrategies = [
  "global",
  "connected",
  "flexible"
];
var scrollStrategies = ["close", "block", "reposition"];
function Scrim(props) {
  const {
    modelValue,
    color,
    ...rest
  } = props;
  return createVNode(Transition, {
    "name": "fade-transition",
    "appear": true
  }, {
    default: () => [props.modelValue && createVNode("div", mergeProps({
      "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
      "style": props.color.backgroundColorStyles.value
    }, rest), null, 16)]
  }, 8, ["appear"]);
}
var CloseScrollStrategy = class {
  constructor({
    content,
    isActive
  }) {
    _defineProperty(this, "scrollElements", []);
    this.content = content;
    this.isActive = isActive;
  }
  enable() {
    this.scrollElements = [document, ...getScrollParents(this.content.value)];
    this.scrollElements.forEach((el) => {
      el.addEventListener("scroll", this.onScroll.bind(this), {
        passive: true
      });
    });
  }
  disable() {
    this.scrollElements.forEach((el) => {
      el.removeEventListener("scroll", this.onScroll.bind(this));
    });
  }
  onScroll() {
    this.isActive.value = false;
  }
};
var BlockScrollStrategy = class {
  constructor({
    content
  }) {
    _defineProperty(this, "initialOverflow", []);
    _defineProperty(this, "scrollElements", []);
    this.content = content;
  }
  enable() {
    this.scrollElements = getScrollParents(this.content.value);
    const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
    document.documentElement.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
    this.scrollElements.forEach((el, i) => {
      this.initialOverflow[i] = el.style.overflowY;
      el.style.overflowY = "hidden";
      el.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
    });
  }
  disable() {
    this.scrollElements.forEach((el, i) => {
      el.style.overflowY = this.initialOverflow[i];
      el.style.removeProperty("--v-scrollbar-offset");
    });
    document.documentElement.style.removeProperty("--v-scrollbar-offset");
  }
};
var VOverlay_default = defineComponent2({
  name: "VOverlay",
  directives: {
    ClickOutside
  },
  inheritAttrs: false,
  props: {
    absolute: Boolean,
    attach: {
      type: [Boolean, String, Object],
      default: "body"
    },
    eager: Boolean,
    noClickAnimation: Boolean,
    modelValue: Boolean,
    origin: [String, Object],
    persistent: Boolean,
    positionStrategy: {
      type: String,
      default: "global",
      validator: (val) => positionStrategies.includes(val)
    },
    scrim: {
      type: [String, Boolean],
      default: true
    },
    scrollStrategy: {
      type: String,
      default: "block",
      validator: (val) => scrollStrategies.includes(val)
    },
    ...makeThemeProps(),
    ...makeTransitionProps()
  },
  emits: {
    "click:outside": (e) => true,
    "update:modelValue": (value) => true
  },
  setup(props, {
    slots,
    attrs,
    emit
  }) {
    const isActive = useProxiedModel(props, "modelValue");
    const {
      teleportTarget
    } = useTeleport(toRef(props, "attach"));
    const {
      themeClasses
    } = useTheme(props);
    const {
      rtlClasses
    } = useRtl();
    const {
      isBooted
    } = useBooted(isActive, toRef(props, "eager"));
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props.scrim === "string" ? props.scrim : null;
    }));
    function onClickOutside(e) {
      emit("click:outside", e);
      if (!props.persistent)
        isActive.value = false;
      else
        animateClick();
    }
    function closeConditional() {
      return isActive.value;
    }
    const activatorElement = ref();
    function onActivatorClick(e) {
      activatorElement.value = e.currentTarget || e.target;
      isActive.value = !isActive.value;
    }
    function onKeydown(e) {
      if (e.key === "Escape") {
        if (!props.persistent) {
          isActive.value = false;
        } else
          animateClick();
      }
    }
    useBackButton((next) => {
      next(!isActive.value);
      if (!props.persistent)
        isActive.value = false;
      else
        animateClick();
    });
    const content = ref();
    watch(isActive, (val) => {
      nextTick(() => {
        if (val) {
          var _content$value;
          (_content$value = content.value) == null ? void 0 : _content$value.focus();
        } else {
          var _activatorElement$val;
          (_activatorElement$val = activatorElement.value) == null ? void 0 : _activatorElement$val.focus();
        }
      });
    });
    const root = ref();
    const top = ref();
    watch(() => isActive.value && props.absolute && teleportTarget.value == null, (val) => {
      if (val) {
        const scrollParent = getScrollParent(root.value);
        if (scrollParent && scrollParent !== document.scrollingElement) {
          top.value = scrollParent.scrollTop;
        }
      }
    });
    function animateClick() {
      var _content$value2;
      if (props.noClickAnimation)
        return;
      (_content$value2 = content.value) == null ? void 0 : _content$value2.animate([{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: standardEasing
      });
    }
    function onAfterLeave() {
      if (!props.eager)
        isBooted.value = false;
    }
    const scrollStrategy = props.scrollStrategy === "close" ? new CloseScrollStrategy({
      content,
      isActive
    }) : props.scrollStrategy === "block" ? new BlockScrollStrategy({
      content
    }) : null;
    if (scrollStrategy) {
      watch(isActive, (val) => {
        nextTick(() => {
          val ? scrollStrategy.enable() : scrollStrategy.disable();
        });
      });
    }
    useRender(() => {
      var _slots$activator, _slots$default;
      return createVNode(Fragment, null, [(_slots$activator = slots.activator) == null ? void 0 : _slots$activator.call(slots, {
        isActive: isActive.value,
        props: {
          modelValue: isActive.value,
          "onUpdate:modelValue": (val) => isActive.value = val,
          onClick: onActivatorClick
        }
      }), createVNode(Teleport, {
        "disabled": !teleportTarget.value,
        "ref": root,
        "to": teleportTarget.value
      }, {
        default: () => [isBooted.value && createVNode("div", mergeProps({
          "class": ["v-overlay", {
            "v-overlay--absolute": props.absolute,
            "v-overlay--active": isActive.value
          }, themeClasses.value, rtlClasses.value],
          "style": top.value != null ? `top: ${convertToUnit(top.value)}` : void 0
        }, attrs), [createVNode(Scrim, {
          "color": scrimColor,
          "modelValue": isActive.value && !!props.scrim
        }, null, 8, ["color", "modelValue"]), createVNode(MaybeTransition, {
          "appear": true,
          "onAfterLeave": onAfterLeave,
          "persisted": true,
          "transition": props.transition
        }, {
          default: () => [withDirectives(createVNode("div", {
            "ref": content,
            "class": "v-overlay__content",
            "tabindex": -1,
            "onKeydown": onKeydown
          }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
            isActive
          })], 40, ["tabindex", "onKeydown"]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
            handler: onClickOutside,
            closeConditional
          }]])]
        }, 8, ["appear", "onAfterLeave", "persisted", "transition"])], 16)]
      }, 8, ["disabled", "to"])]);
    });
    return {
      animateClick,
      content
    };
  }
});

// node_modules/vuetify/lib/components/VDialog/VDialog.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VDialog/VDialog.sass";
var VDialog_default = defineComponent2({
  name: "VDialog",
  props: {
    fullscreen: Boolean,
    origin: {
      type: String,
      default: "center center"
    },
    retainFocus: {
      type: Boolean,
      default: true
    },
    scrollable: Boolean,
    modelValue: Boolean,
    ...makeDimensionProps({
      width: "auto"
    }),
    ...makeTransitionProps({
      transition: {
        component: dialog_transition_default
      }
    })
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, {
    attrs,
    slots
  }) {
    const isActive = useProxiedModel(props, "modelValue");
    const {
      dimensionStyles
    } = useDimension(props);
    const overlay = ref();
    function onFocusin(e) {
      var _overlay$value;
      const before = e.relatedTarget;
      const after = e.target;
      if (before !== after && (_overlay$value = overlay.value) != null && _overlay$value.content && ![document, overlay.value.content].includes(after) && !overlay.value.content.contains(after)) {
        const focusable = [...overlay.value.content.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter((el) => !el.hasAttribute("disabled"));
        if (!focusable.length)
          return;
        const firstElement = focusable[0];
        const lastElement = focusable[focusable.length - 1];
        if (before === firstElement) {
          lastElement.focus();
        } else {
          firstElement.focus();
        }
      }
    }
    if (IN_BROWSER) {
      watch(() => isActive.value && props.retainFocus, (val) => {
        val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
      }, {
        immediate: true
      });
    }
    const activatorElement = ref();
    const activator = ({
      props: props2,
      ...data
    }) => {
      var _slots$activator;
      return (_slots$activator = slots.activator) == null ? void 0 : _slots$activator.call(slots, {
        ...data,
        props: mergeProps(props2, {
          "aria-haspopup": "dialog",
          onClick: (e) => {
            activatorElement.value = e.currentTarget;
          }
        })
      });
    };
    return () => {
      const transition = mergeProps({
        target: activatorElement.value
      }, typeof props.transition === "string" ? {
        name: props.transition
      } : props.transition);
      return createVNode(VOverlay_default, mergeProps({
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "class": ["v-dialog", {
          "v-dialog--fullscreen": props.fullscreen
        }],
        "style": dimensionStyles.value,
        "transition": transition,
        "ref": overlay,
        "aria-role": "dialog",
        "aria-modal": "true"
      }, attrs), {
        default: slots.default,
        activator
      }, 16, ["modelValue", "onUpdate:modelValue", "class", "style", "transition"]);
    };
  }
});

// node_modules/vuetify/lib/components/VDivider/VDivider.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VDivider/VDivider.sass";
var VDivider_default = defineComponent2({
  name: "VDivider",
  props: {
    inset: Boolean,
    length: [Number, String],
    thickness: [Number, String],
    vertical: Boolean,
    ...makeThemeProps()
  },
  setup(props, {
    attrs
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const dividerStyles = computed(() => {
      const styles = {};
      if (props.length) {
        styles[props.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(props.length);
      }
      if (props.thickness) {
        styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
      }
      return styles;
    });
    return () => {
      return createVNode("hr", {
        "class": [{
          "v-divider": true,
          "v-divider--inset": props.inset,
          "v-divider--vertical": props.vertical
        }, themeClasses.value],
        "style": dividerStyles.value,
        "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
        "role": `${attrs.role || "separator"}`
      }, null, 14, ["aria-orientation"]);
    };
  }
});

// node_modules/vuetify/lib/components/VFooter/VFooter.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VFooter/VFooter.sass";
var VFooter_default = defineComponent2({
  name: "VFooter",
  props: {
    ...makeBorderProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeTagProps({
      tag: "footer"
    }),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-footer");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, "v-footer");
    const {
      roundedClasses
    } = useRounded(props, "v-footer");
    return () => createVNode(props.tag, {
      "class": ["v-footer", themeClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value],
      "style": [dimensionStyles.value, positionStyles.value]
    }, slots, 8, ["class", "style"]);
  }
});

// node_modules/vuetify/lib/components/VGrid/VContainer.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VGrid/VGrid.sass";
var VContainer_default = defineComponent2({
  name: "VContainer",
  props: {
    fluid: {
      type: Boolean,
      default: false
    },
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    return () => createVNode(props.tag, {
      "class": ["v-container", {
        "v-container--fluid": props.fluid
      }]
    }, slots, 8, ["class"]);
  }
});

// node_modules/vuetify/lib/components/VGrid/VCol.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VGrid/VGrid.sass";
var breakpoints = ["sm", "md", "lg", "xl", "xxl"];
var breakpointProps = (() => {
  return breakpoints.reduce((props, val) => {
    props[val] = {
      type: [Boolean, String, Number],
      default: false
    };
    return props;
  }, {});
})();
var offsetProps = (() => {
  return breakpoints.reduce((props, val) => {
    props["offset" + capitalize(val)] = {
      type: [String, Number],
      default: null
    };
    return props;
  }, {});
})();
var orderProps = (() => {
  return breakpoints.reduce((props, val) => {
    props["order" + capitalize(val)] = {
      type: [String, Number],
      default: null
    };
    return props;
  }, {});
})();
var propMap = {
  col: Object.keys(breakpointProps),
  offset: Object.keys(offsetProps),
  order: Object.keys(orderProps)
};
function breakpointClass(type, prop, val) {
  let className = type;
  if (val == null || val === false) {
    return void 0;
  }
  if (prop) {
    const breakpoint = prop.replace(type, "");
    className += `-${breakpoint}`;
  }
  if (type === "col") {
    className = "v-" + className;
  }
  if (type === "col" && (val === "" || val === true)) {
    return className.toLowerCase();
  }
  className += `-${val}`;
  return className.toLowerCase();
}
var VCol_default = defineComponent2({
  name: "VCol",
  props: {
    cols: {
      type: [Boolean, String, Number],
      default: false
    },
    ...breakpointProps,
    offset: {
      type: [String, Number],
      default: null
    },
    ...offsetProps,
    order: {
      type: [String, Number],
      default: null
    },
    ...orderProps,
    alignSelf: {
      type: String,
      default: null,
      validator: (str) => ["auto", "start", "end", "center", "baseline", "stretch"].includes(str)
    },
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    const classes = computed(() => {
      const classList = [];
      let type;
      for (type in propMap) {
        propMap[type].forEach((prop) => {
          const value = props[prop];
          const className = breakpointClass(type, prop, value);
          if (className)
            classList.push(className);
        });
      }
      const hasColClasses = classList.some((className) => className.startsWith("v-col-"));
      classList.push({
        "v-col": !hasColClasses || !props.cols,
        [`v-col-${props.cols}`]: props.cols,
        [`offset-${props.offset}`]: props.offset,
        [`order-${props.order}`]: props.order,
        [`align-self-${props.alignSelf}`]: props.alignSelf
      });
      return classList;
    });
    return () => {
      var _slots$default;
      return h(props.tag, {
        class: classes.value
      }, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots));
    };
  }
});

// node_modules/vuetify/lib/components/VGrid/VRow.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VGrid/VGrid.sass";
var breakpoints2 = ["sm", "md", "lg", "xl", "xxl"];
var ALIGNMENT = ["start", "end", "center"];
function makeRowProps(prefix, def) {
  return breakpoints2.reduce((props, val) => {
    props[prefix + capitalize(val)] = def();
    return props;
  }, {});
}
var alignValidator = (str) => [...ALIGNMENT, "baseline", "stretch"].includes(str);
var alignProps = makeRowProps("align", () => ({
  type: String,
  default: null,
  validator: alignValidator
}));
var justifyValidator = (str) => [...ALIGNMENT, "space-between", "space-around"].includes(str);
var justifyProps = makeRowProps("justify", () => ({
  type: String,
  default: null,
  validator: justifyValidator
}));
var alignContentValidator = (str) => [...ALIGNMENT, "space-between", "space-around", "stretch"].includes(str);
var alignContentProps = makeRowProps("alignContent", () => ({
  type: String,
  default: null,
  validator: alignContentValidator
}));
var propMap2 = {
  align: Object.keys(alignProps),
  justify: Object.keys(justifyProps),
  alignContent: Object.keys(alignContentProps)
};
var classMap = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function breakpointClass2(type, prop, val) {
  let className = classMap[type];
  if (val == null) {
    return void 0;
  }
  if (prop) {
    const breakpoint = prop.replace(type, "");
    className += `-${breakpoint}`;
  }
  className += `-${val}`;
  return className.toLowerCase();
}
var VRow_default = defineComponent2({
  name: "VRow",
  props: {
    dense: Boolean,
    noGutters: Boolean,
    align: {
      type: String,
      default: null,
      validator: alignValidator
    },
    ...alignProps,
    justify: {
      type: String,
      default: null,
      validator: justifyValidator
    },
    ...justifyProps,
    alignContent: {
      type: String,
      default: null,
      validator: alignContentValidator
    },
    ...alignContentProps,
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    const classes = computed(() => {
      const classList = [];
      let type;
      for (type in propMap2) {
        propMap2[type].forEach((prop) => {
          const value = props[prop];
          const className = breakpointClass2(type, prop, value);
          if (className)
            classList.push(className);
        });
      }
      classList.push({
        "v-row--no-gutters": props.noGutters,
        "v-row--dense": props.dense,
        [`align-${props.align}`]: props.align,
        [`justify-${props.justify}`]: props.justify,
        [`align-content-${props.alignContent}`]: props.alignContent
      });
      return classList;
    });
    return () => {
      var _slots$default;
      return h(props.tag, {
        class: ["v-row", classes.value]
      }, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots));
    };
  }
});

// node_modules/vuetify/lib/components/VGrid/VSpacer.mjs
var VSpacer_default = createSimpleFunctional("flex-grow-1", "div", "VSpacer");

// node_modules/vuetify/lib/composables/delay.mjs
var makeDelayProps = propsFactory({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function useDelay(props, cb) {
  const delays = {};
  const runDelayFactory = (prop) => () => {
    if (!IN_BROWSER)
      return Promise.resolve(true);
    const active = prop === "openDelay";
    delays.closeDelay && window.clearTimeout(delays.closeDelay);
    delete delays.closeDelay;
    delays.openDelay && window.clearTimeout(delays.openDelay);
    delete delays.openDelay;
    return new Promise((resolve) => {
      var _props$prop;
      const delay = parseInt((_props$prop = props[prop]) != null ? _props$prop : 0, 10);
      delays[prop] = window.setTimeout(() => {
        cb == null ? void 0 : cb(active);
        resolve(active);
      }, delay);
    });
  };
  return {
    runCloseDelay: runDelayFactory("closeDelay"),
    runOpenDelay: runDelayFactory("openDelay")
  };
}

// node_modules/vuetify/lib/components/VHover/VHover.mjs
var VHover_default = defineComponent2({
  name: "VHover",
  props: {
    disabled: Boolean,
    modelValue: {
      type: Boolean,
      default: void 0
    },
    ...makeDelayProps()
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, {
    slots
  }) {
    const hover = useProxiedModel(props, "modelValue");
    const {
      runOpenDelay,
      runCloseDelay
    } = useDelay(props, (value) => !props.disabled && (hover.value = value));
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        hover: hover.value,
        props: {
          onMouseenter: runOpenDelay,
          onMouseleave: runCloseDelay
        }
      });
    };
  }
});

// node_modules/vuetify/lib/components/VInput/VInputLabel.mjs
var VInputLabel_default = defineComponent2({
  name: "VInputLabel",
  props: {
    floating: Boolean,
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    return () => {
      var _slots$default;
      return createVNode("label", {
        "class": ["v-input-label", {
          "v-input-label--floating": props.floating
        }],
        "aria-hidden": props.floating || void 0
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 10, ["aria-hidden"]);
    };
  }
});

// node_modules/vuetify/lib/components/VInput/VInput.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VInput/VInput.sass";
var allowedVariants2 = ["underlined", "outlined", "filled", "contained", "plain"];
var VInput_default = defineComponent2({
  name: "VInput",
  inheritAttrs: false,
  props: {
    active: Boolean,
    appendIcon: String,
    appendOuterIcon: String,
    bgColor: String,
    color: String,
    hideDetails: [Boolean, String],
    hideSpinButtons: Boolean,
    hint: String,
    id: String,
    label: String,
    loading: Boolean,
    modelValue: null,
    persistentHint: Boolean,
    prependIcon: String,
    prependOuterIcon: String,
    reverse: Boolean,
    singleLine: Boolean,
    variant: {
      type: String,
      default: "filled",
      validator: (v) => allowedVariants2.includes(v)
    },
    ...makeThemeProps(),
    ...makeDensityProps()
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:active": (value) => true,
    "click:prepend-outer": (e) => e,
    "click:prepend": (e) => e,
    "click:append": (e) => e,
    "click:append-outer": (e) => e
  },
  setup(props, {
    attrs,
    emit,
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      densityClasses
    } = useDensity(props, "v-input");
    const value = useProxiedModel(props, "modelValue");
    const isActive = useProxiedModel(props, "active");
    const uid = getUid();
    const labelRef = ref();
    const floatingLabelRef = ref();
    const controlRef = ref();
    const fieldRef = ref();
    const inputRef = ref();
    const isDirty = computed(() => value.value != null && value.value !== "");
    const isFocused = ref(false);
    const id = computed(() => props.id || `input-${uid}`);
    watchEffect(() => isActive.value = isFocused.value || isDirty.value);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => {
      return isFocused.value ? props.color : void 0;
    }));
    watch(isActive, (val) => {
      if (!props.singleLine) {
        const el = labelRef.value.$el;
        const targetEl = floatingLabelRef.value.$el;
        const rect = nullifyTransforms(el);
        const targetRect = targetEl.getBoundingClientRect();
        const x = targetRect.x - rect.x;
        const y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
        const targetWidth = targetRect.width / 0.75;
        const width = Math.abs(targetWidth - rect.width) > 1 ? {
          maxWidth: convertToUnit(targetWidth)
        } : void 0;
        const duration = parseFloat(getComputedStyle(el).transitionDuration) * 1e3;
        const scale = parseFloat(getComputedStyle(targetEl).getPropertyValue("--v-input-label-scale"));
        el.style.visibility = "visible";
        targetEl.style.visibility = "hidden";
        el.animate([{
          transform: "translate(0)"
        }, {
          transform: `translate(${x}px, ${y}px) scale(${scale})`,
          ...width
        }], {
          duration,
          easing: standardEasing,
          direction: val ? "normal" : "reverse"
        }).finished.then(() => {
          el.style.removeProperty("visibility");
          targetEl.style.removeProperty("visibility");
        });
      }
    }, {
      flush: "post"
    });
    function onMousedown(e) {
      if (e.target !== document.activeElement) {
        e.preventDefault();
      }
      focus();
    }
    function focus() {
      var _inputRef$value;
      (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.focus();
    }
    function blur() {
      var _inputRef$value2;
      (_inputRef$value2 = inputRef.value) == null ? void 0 : _inputRef$value2.blur();
    }
    useRender(() => {
      var _slots$default;
      const isOutlined = props.variant === "outlined";
      const hasPrepend = slots.prepend || props.prependIcon;
      const hasPrependOuter = slots.prependOuter || props.prependOuterIcon;
      const hasAppend = slots.append || props.appendIcon;
      const hasAppendOuter = slots.appendOuter || props.appendOuterIcon;
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      return createVNode("div", mergeProps({
        "class": ["v-input", {
          "v-input--prepended": hasPrepend,
          "v-input--appended": hasAppend,
          "v-input--dirty": isActive.value,
          "v-input--focused": isFocused.value,
          "v-input--reverse": props.reverse,
          "v-input--has-background": !!props.bgColor,
          "v-input--single-line": props.singleLine,
          [`v-input--variant-${props.variant}`]: true
        }, themeClasses.value, densityClasses.value, textColorClasses.value],
        "style": [textColorStyles.value]
      }, attrs), [hasPrependOuter && createVNode("div", {
        "class": "v-input__prepend-outer",
        "onClick": (e) => emit("click:prepend-outer", e)
      }, [slots.prependOuter ? slots.prependOuter() : createVNode(VIcon_default, {
        "icon": props.prependOuterIcon
      }, null, 8, ["icon"])], 8, ["onClick"]), createVNode("div", {
        "ref": controlRef,
        "class": ["v-input__control", backgroundColorClasses.value],
        "style": backgroundColorStyles.value,
        "onMousedown": onMousedown
      }, [createVNode("div", {
        "class": "v-input__overlay"
      }, null), hasPrepend && createVNode("div", {
        "class": "v-input__prepend",
        "onClick": (e) => emit("click:prepend", e)
      }, [slots.prepend ? slots.prepend() : createVNode(VIcon_default, {
        "icon": props.prependIcon
      }, null, 8, ["icon"])], 8, ["onClick"]), createVNode("div", {
        "class": "v-input__field",
        "ref": fieldRef
      }, [["contained", "filled"].includes(props.variant) && !props.singleLine && createVNode(VInputLabel_default, {
        "ref": floatingLabelRef,
        "floating": true
      }, {
        default: () => [label],
        _: 2
      }, 8, ["floating"]), createVNode(VInputLabel_default, {
        "ref": labelRef,
        "for": id.value
      }, {
        default: () => [label],
        _: 2
      }, 8, ["for"]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        uid,
        isActive: isActive.value,
        props: {
          id: id.value,
          value: value.value,
          ref: inputRef,
          onFocus: () => isFocused.value = true,
          onBlur: () => isFocused.value = false,
          onInput: (e) => {
            const el = e.target;
            value.value = el.value;
          },
          onChange: (e) => {
            const el = e.target;
            if (value.value === el.value)
              return;
            value.value = el.value;
          }
        }
      })], 512), hasAppend && createVNode("div", {
        "class": "v-input__append",
        "onClick": (e) => emit("click:append", e)
      }, [slots.append ? slots.append() : createVNode(VIcon_default, {
        "icon": props.appendIcon
      }, null, 8, ["icon"])], 8, ["onClick"]), createVNode("div", {
        "class": "v-input__outline"
      }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
        "class": "v-input__outline__start"
      }, null), createVNode("div", {
        "class": "v-input__outline__notch"
      }, [!props.singleLine && createVNode(VInputLabel_default, {
        "ref": floatingLabelRef,
        "floating": true
      }, {
        default: () => [label],
        _: 2
      }, 8, ["floating"])]), createVNode("div", {
        "class": "v-input__outline__end"
      }, null)]), ["plain", "underlined"].includes(props.variant) && !props.singleLine && createVNode(VInputLabel_default, {
        "ref": floatingLabelRef,
        "floating": true
      }, {
        default: () => [label],
        _: 2
      }, 8, ["floating"])])], 46, ["onMousedown"]), hasAppendOuter && createVNode("div", {
        "class": "v-input__append-outer",
        "onClick": (e) => emit("click:append-outer", e)
      }, [slots.appendOuter ? slots.appendOuter() : createVNode(VIcon_default, {
        "icon": props.appendOuterIcon
      }, null, 8, ["icon"])], 8, ["onClick"]), slots.details && createVNode("div", {
        "class": "v-input__details"
      }, [slots.details()])], 16);
    });
    return {
      blur,
      focus,
      value,
      isActive,
      isDirty,
      isFocused
    };
  }
});

// node_modules/vuetify/lib/components/VKbd/index.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VKbd/VKbd.sass";
var VKbd = createSimpleFunctional("v-kbd");

// node_modules/vuetify/lib/components/VItemGroup/VItemGroup.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VItemGroup/VItemGroup.sass";

// node_modules/vuetify/lib/composables/group.mjs
var makeGroupProps = propsFactory({
  modelValue: {
    type: [Number, Boolean, String, Array, Object],
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String
}, "group");
var makeGroupItemProps = propsFactory({
  value: {
    type: [Number, Boolean, String, Object],
    default: void 0
  },
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function useGroupItem(props, injectKey) {
  const vm = getCurrentInstance();
  if (!vm) {
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  }
  const group = inject(injectKey, null);
  if (!group) {
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
  }
  const id = getUid();
  const value = toRef(props, "value");
  const disabled = toRef(props, "disabled");
  group.register({
    id,
    value,
    disabled
  }, vm);
  onBeforeUnmount(() => {
    group.unregister(id);
  });
  const isSelected = computed(() => {
    return group.isSelected(id);
  });
  const selectedClass = computed(() => {
    var _group$selectedClass$;
    return isSelected.value && ((_group$selectedClass$ = group.selectedClass.value) != null ? _group$selectedClass$ : props.selectedClass);
  });
  return {
    isSelected,
    toggle: () => group.select(id, !isSelected.value),
    select: (value2) => group.select(id, value2),
    selectedClass,
    value,
    disabled
  };
}
function useGroup(props, injectKey) {
  let isUnmounted = false;
  const items = reactive([]);
  const selected = useProxiedModel(props, "modelValue", [], (v) => {
    if (v == null)
      return [];
    return getIds(items, wrapInArray(v));
  }, (v) => {
    const arr = getValues(items, v);
    return props.multiple ? arr : arr[0];
  });
  const groupVm = getCurrentInstance();
  function register(item, vm) {
    const unwrapped = item;
    const children = findChildren(groupVm == null ? void 0 : groupVm.vnode);
    const instances = children.slice(1).filter((cmp) => !!cmp.provides[injectKey]);
    const index = instances.indexOf(vm);
    if (index > -1)
      items.splice(index, 0, unwrapped);
    else
      items.push(unwrapped);
  }
  function unregister(id) {
    if (isUnmounted)
      return;
    selected.value = selected.value.filter((v) => v !== id);
    forceMandatoryValue();
    const index = items.findIndex((item) => item.id === id);
    items.splice(index, 1);
  }
  function forceMandatoryValue() {
    const item = items.find((item2) => !item2.disabled);
    if (item && props.mandatory === "force" && !selected.value.length) {
      selected.value = [item.id];
    }
  }
  onMounted(() => {
    forceMandatoryValue();
  });
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function select(id, isSelected) {
    const item = items.find((item2) => item2.id === id);
    if (isSelected && item != null && item.disabled)
      return;
    if (props.multiple) {
      const internalValue = selected.value.slice();
      const index = internalValue.findIndex((v) => v === id);
      if (props.mandatory && index > -1 && internalValue.length <= 1)
        return;
      if (props.max != null && index < 0 && internalValue.length + 1 > props.max)
        return;
      if (index < 0 && isSelected)
        internalValue.push(id);
      else if (index >= 0 && !isSelected)
        internalValue.splice(index, 1);
      selected.value = internalValue;
    } else {
      if (props.mandatory && selected.value.includes(id))
        return;
      selected.value = isSelected ? [id] : [];
    }
  }
  function step(offset) {
    if (props.multiple)
      consoleWarn('This method is not supported when using "multiple" prop');
    if (!selected.value.length) {
      const item = items.find((item2) => !item2.disabled);
      item && (selected.value = [item.id]);
    } else {
      const currentId = selected.value[0];
      const currentIndex = items.findIndex((i) => i.id === currentId);
      let newIndex = (currentIndex + offset) % items.length;
      let newItem = items[newIndex];
      while (newItem.disabled && newIndex !== currentIndex) {
        newIndex = (newIndex + offset) % items.length;
        newItem = items[newIndex];
      }
      if (newItem.disabled)
        return;
      selected.value = [items[newIndex].id];
    }
  }
  const state = {
    register,
    unregister,
    selected,
    select,
    prev: () => step(items.length - 1),
    next: () => step(1),
    isSelected: (id) => selected.value.includes(id),
    selectedClass: computed(() => props.selectedClass)
  };
  provide(injectKey, state);
  return state;
}
function getIds(items, modelValue) {
  const ids = [];
  for (const item of items) {
    if (item.value != null) {
      if (modelValue.find((value) => deepEqual(value, item.value))) {
        ids.push(item.id);
      }
    } else if (modelValue.includes(item.id)) {
      ids.push(item.id);
    }
  }
  return ids;
}
function getValues(items, ids) {
  const values = [];
  for (const item of items) {
    if (ids.includes(item.id)) {
      values.push(item.value != null ? item.value : item.id);
    }
  }
  return values;
}

// node_modules/vuetify/lib/components/VItemGroup/VItemGroup.mjs
var VItemGroupSymbol = Symbol.for("vuetify:v-item-group");
var VItemGroup_default = defineComponent2({
  name: "VItemGroup",
  props: {
    ...makeGroupProps({
      selectedClass: "v-item--selected"
    }),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props, VItemGroupSymbol);
    return () => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-item-group", themeClasses.value]
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })]
      }, 8, ["class"]);
    };
  }
});

// node_modules/vuetify/lib/components/VItemGroup/VItem.mjs
var VItem_default = defineComponent2({
  name: "VItem",
  props: makeGroupItemProps(),
  setup(props, {
    slots
  }) {
    const {
      isSelected,
      select,
      toggle,
      selectedClass,
      value,
      disabled
    } = useGroupItem(props, VItemGroupSymbol);
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        isSelected: isSelected.value,
        selectedClass: selectedClass.value,
        select,
        toggle,
        value: value.value,
        disabled: disabled.value
      });
    };
  }
});

// node_modules/vuetify/lib/components/VLayout/VLayout.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VLayout/VLayout.sass";
var VLayout_default = defineComponent2({
  name: "VLayout",
  props: makeLayoutProps(),
  setup(props, {
    slots
  }) {
    const {
      layoutClasses,
      getLayoutItem,
      items
    } = createLayout(props);
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "class": layoutClasses.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 2);
    });
    return {
      getLayoutItem,
      items
    };
  }
});

// node_modules/vuetify/lib/components/VLayout/VLayoutItem.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VLayout/VLayoutItem.sass";
var VLayoutItem_default = defineComponent2({
  name: "VLayoutItem",
  props: {
    position: {
      type: String,
      required: true
    },
    size: {
      type: [Number, String],
      default: 300
    },
    modelValue: Boolean,
    ...makeLayoutItemProps()
  },
  setup(props, {
    slots
  }) {
    const styles = useLayoutItem(props.name, toRef(props, "priority"), toRef(props, "position"), toRef(props, "size"), toRef(props, "size"), toRef(props, "modelValue"));
    return () => {
      var _slots$default;
      return createVNode("div", {
        "class": ["v-layout-item", {
          "v-layout-item--absolute": props.absolute
        }],
        "style": styles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 6);
    };
  }
});

// node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.sass";

// node_modules/vuetify/lib/composables/locale.mjs
var LocaleAdapterSymbol = Symbol.for("vuetify:locale-adapter");
var VuetifyLocaleSymbol = Symbol.for("vuetify:locale");
function provideLocale(props) {
  const adapter = inject(LocaleAdapterSymbol);
  if (!adapter)
    throw new Error("[Vuetify] Could not find injected locale adapter");
  return adapter.createScope(props);
}
function useLocale() {
  const adapter = inject(LocaleAdapterSymbol);
  if (!adapter)
    throw new Error("[Vuetify] Could not find injected locale adapter");
  return adapter.getScope();
}
function isLocaleAdapter(x) {
  return !!x && x.hasOwnProperty("getScope") && x.hasOwnProperty("createScope") && x.hasOwnProperty("createRoot");
}
function createLocaleAdapter(app, options) {
  const adapter = isLocaleAdapter(options) ? options : createDefaultLocaleAdapter(options);
  const rootInstance = adapter.createRoot(app);
  return {
    adapter,
    rootInstance
  };
}
var LANG_PREFIX = "$vuetify.";
var replace = (str, params) => {
  return str.replace(/\{(\d+)\}/g, (match, index) => {
    return String(params[+index]);
  });
};
var createTranslateFunction = (current, fallback, messages) => {
  return (key, ...params) => {
    if (!key.startsWith(LANG_PREFIX)) {
      return replace(key, params);
    }
    const shortKey = key.replace(LANG_PREFIX, "");
    const currentLocale = current.value && messages.value[current.value];
    const fallbackLocale = fallback.value && messages.value[fallback.value];
    let str = getObjectValueByPath(currentLocale, shortKey, null);
    if (!str) {
      consoleWarn(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
      str = getObjectValueByPath(fallbackLocale, shortKey, null);
    }
    if (!str) {
      consoleError(`Translation key "${key}" not found in fallback`);
      str = key;
    }
    if (typeof str !== "string") {
      consoleError(`Translation key "${key}" has a non-string value`);
      str = key;
    }
    return replace(str, params);
  };
};
function createNumberFunction(current, fallback) {
  return (value, options) => {
    const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
    return numberFormat.format(value);
  };
}
function createDefaultLocaleAdapter(options) {
  const createScope = (options2) => {
    const current = wrapInRef(options2.current);
    const fallback = wrapInRef(options2.fallback);
    const messages = wrapInRef(options2.messages);
    return {
      current,
      fallback,
      messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback)
    };
  };
  return {
    createRoot: (app) => {
      var _options$defaultLocal, _options$fallbackLoca, _options$messages;
      const rootScope = createScope({
        current: (_options$defaultLocal = options == null ? void 0 : options.defaultLocale) != null ? _options$defaultLocal : "en",
        fallback: (_options$fallbackLoca = options == null ? void 0 : options.fallbackLocale) != null ? _options$fallbackLoca : "en",
        messages: (_options$messages = options == null ? void 0 : options.messages) != null ? _options$messages : {
          en: en_default
        }
      });
      app.provide(VuetifyLocaleSymbol, rootScope);
      return rootScope;
    },
    getScope: () => {
      const currentScope = inject(VuetifyLocaleSymbol);
      if (!currentScope)
        throw new Error("[Vuetify] Could not find injected locale instance");
      return currentScope;
    },
    createScope: (options2) => {
      const currentScope = inject(VuetifyLocaleSymbol);
      if (!currentScope)
        throw new Error("[Vuetify] Could not find injected locale instance");
      const newScope = createScope({
        current: computed(() => {
          var _options$locale;
          return (_options$locale = options2 == null ? void 0 : options2.locale) != null ? _options$locale : currentScope.current.value;
        }),
        fallback: computed(() => {
          var _options$locale2;
          return (_options$locale2 = options2 == null ? void 0 : options2.locale) != null ? _options$locale2 : currentScope.fallback.value;
        }),
        messages: computed(() => {
          var _options$messages2;
          return (_options$messages2 = options2 == null ? void 0 : options2.messages) != null ? _options$messages2 : currentScope.messages.value;
        })
      });
      provide(VuetifyLocaleSymbol, newScope);
      return newScope;
    }
  };
}

// node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.mjs
var VLocaleProvider_default = defineComponent2({
  name: "VLocaleProvider",
  props: {
    locale: String,
    fallbackLocale: String,
    messages: Object,
    rtl: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props, {
    slots
  }) {
    const localeInstance = provideLocale(props);
    const {
      rtlClasses
    } = provideRtl(props, localeInstance);
    return () => {
      var _slots$default;
      return createVNode("div", {
        "class": ["v-locale-provider", rtlClasses.value]
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 2);
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListSubheader.mjs
var VListSubheader_default = defineComponent2({
  name: "VListSubheader",
  props: {
    color: String,
    inset: Boolean,
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    return () => createVNode(props.tag, {
      "class": ["v-list-subheader", {
        "v-list-subheader--inset": props.inset
      }, textColorClasses.value],
      "style": {
        textColorStyles
      }
    }, {
      default: () => [slots.default && createVNode("div", {
        "class": "v-list-subheader__text"
      }, [slots.default()])]
    }, 8, ["class", "style"]);
  }
});

// node_modules/vuetify/lib/components/VList/VList.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VList/VList.sass";
var VList_default = defineComponent2({
  name: "VList",
  props: {
    color: String,
    disabled: Boolean,
    lines: {
      type: String,
      default: "one"
    },
    nav: Boolean,
    subheader: {
      type: [Boolean, String],
      default: false
    },
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      borderClasses
    } = useBorder(props, "v-list");
    const {
      densityClasses
    } = useDensity(props, "v-list");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, "v-list");
    return () => {
      var _slots$default;
      const hasHeader = typeof props.subheader === "string" || slots.subheader;
      return createVNode(props.tag, {
        "class": ["v-list", {
          "v-list--disabled": props.disabled,
          "v-list--nav": props.nav,
          "v-list--subheader": props.subheader,
          "v-list--subheader-sticky": props.subheader === "sticky",
          [`v-list--${props.lines}-line`]: true
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, dimensionStyles.value]
      }, {
        default: () => [hasHeader && (slots.subheader ? slots.subheader() : createVNode(VListSubheader_default, null, {
          default: () => [props.subheader]
        })), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListImg.mjs
var VListImg_default = createSimpleFunctional("v-list-img");

// node_modules/vuetify/lib/components/VList/VListItemAvatar.mjs
var VListItemAvatar_default = defineComponent2({
  name: "VListItemAvatar",
  props: {
    left: Boolean,
    right: Boolean,
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    return () => {
      return createVNode(props.tag, {
        "class": ["v-list-item-avatar", {
          "v-list-item-avatar--start": props.left,
          "v-list-item-avatar--end": props.right
        }]
      }, slots, 8, ["class"]);
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListItemHeader.mjs
var VListItemHeader_default = createSimpleFunctional("v-list-item-header");

// node_modules/vuetify/lib/components/VList/VListItemSubtitle.mjs
var VListItemSubtitle_default = createSimpleFunctional("v-list-item-subtitle");

// node_modules/vuetify/lib/components/VList/VListItemTitle.mjs
var VListItemTitle_default = createSimpleFunctional("v-list-item-title");

// node_modules/vuetify/lib/components/VList/VListItem.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VList/VListItem.sass";
var VListItem_default = defineComponent2({
  name: "VListItem",
  directives: {
    Ripple
  },
  props: {
    active: Boolean,
    activeColor: String,
    activeClass: String,
    appendAvatar: String,
    appendIcon: String,
    disabled: Boolean,
    link: Boolean,
    prependAvatar: String,
    prependIcon: String,
    subtitle: String,
    title: String,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "text"
    })
  },
  setup(props, {
    attrs,
    slots
  }) {
    var _props$activeColor;
    const link = useLink(props, attrs);
    const isActive = computed(() => {
      var _link$isExactActive;
      return props.active || ((_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value);
    });
    const activeColor = (_props$activeColor = props.activeColor) != null ? _props$activeColor : props.color;
    const variantProps = computed(() => ({
      color: isActive.value ? activeColor : props.color,
      textColor: props.textColor,
      variant: props.variant
    }));
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-list-item");
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps, "v-list-item");
    const {
      densityClasses
    } = useDensity(props, "v-list-item");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, "v-list-item");
    return () => {
      var _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasTitle = slots.title || props.title;
      const hasSubtitle = slots.subtitle || props.subtitle;
      const hasHeader = !!(hasTitle || hasSubtitle);
      const hasAppend = slots.append || props.appendAvatar || props.appendIcon;
      const hasPrepend = slots.prepend || props.prependAvatar || props.prependIcon;
      const isClickable = !props.disabled && (link.isClickable.value || props.link);
      return withDirectives(createVNode(Tag, {
        "class": ["v-list-item", {
          "v-list-item--active": isActive.value,
          "v-list-item--disabled": props.disabled,
          "v-list-item--link": isClickable,
          [`${props.activeClass}`]: isActive.value && props.activeClass
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value],
        "href": link.href.value,
        "tabindex": isClickable ? 0 : void 0,
        "onClick": isClickable && link.navigate
      }, {
        default: () => [genOverlays(!!(isClickable || isActive.value), "v-list-item"), hasPrepend && (slots.prepend ? slots.prepend() : createVNode(VListItemAvatar_default, {
          "left": true
        }, {
          default: () => [createVNode(VAvatar_default, {
            "density": props.density,
            "icon": props.prependIcon,
            "image": props.prependAvatar
          }, null, 8, ["density", "icon", "image"])]
        }, 8, ["left"])), hasHeader && createVNode(VListItemHeader_default, null, {
          default: () => [hasTitle && createVNode(VListItemTitle_default, null, {
            default: () => [slots.title ? slots.title() : props.title]
          }), hasSubtitle && createVNode(VListItemSubtitle_default, null, {
            default: () => [slots.subtitle ? slots.subtitle() : props.subtitle]
          })],
          _: 1
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), hasAppend && (slots.append ? slots.append() : createVNode(VListItemAvatar_default, {
          "right": true
        }, {
          default: () => [createVNode(VAvatar_default, {
            "density": props.density,
            "icon": props.appendIcon,
            "image": props.appendAvatar
          }, null, 8, ["density", "icon", "image"])]
        }, 8, ["right"]))],
        _: 1
      }, 8, ["class", "style", "href", "tabindex", "onClick"]), [[resolveDirective("ripple"), isClickable]]);
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListItemMedia.mjs
var VListItemMedia_default = defineComponent2({
  name: "VListItemMedia",
  props: {
    left: Boolean,
    right: Boolean,
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    return () => {
      return createVNode(props.tag, {
        "class": ["v-list-item-media", {
          "v-list-item-media--start": props.left,
          "v-list-item-media--end": props.right
        }]
      }, slots, 8, ["class"]);
    };
  }
});

// node_modules/vuetify/lib/components/VLazy/VLazy.mjs
var VLazy_default = defineComponent2({
  name: "VLazy",
  directives: {
    intersect: intersect_default
  },
  props: {
    modelValue: Boolean,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    },
    ...makeDimensionProps(),
    ...makeTagProps(),
    ...makeTransitionProps({
      transition: "fade-transition"
    })
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, {
    slots
  }) {
    const {
      dimensionStyles
    } = useDimension(props);
    const isActive = useProxiedModel(props, "modelValue");
    function onIntersect(isIntersecting) {
      if (isActive.value)
        return;
      isActive.value = isIntersecting;
    }
    return () => {
      var _slots$default;
      return withDirectives(createVNode(props.tag, {
        "class": "v-lazy",
        "style": dimensionStyles.value
      }, {
        default: () => [isActive.value && createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
        }, 8, ["transition"])]
      }, 8, ["style"]), [[resolveDirective("intersect"), onIntersect, props.options]]);
    };
  }
});

// node_modules/vuetify/lib/components/VMain/VMain.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VMain/VMain.sass";

// node_modules/vuetify/lib/composables/ssrBoot.mjs
function useSsrBoot() {
  const isBooted = ref(false);
  onMounted(() => {
    window.requestAnimationFrame(() => {
      isBooted.value = true;
    });
  });
  const ssrBootStyles = computed(() => !isBooted.value ? {
    transition: "none !important"
  } : void 0);
  return {
    ssrBootStyles
  };
}

// node_modules/vuetify/lib/components/VMain/VMain.mjs
var VMain_default = defineComponent2({
  name: "VMain",
  props: makeTagProps({
    tag: "main"
  }),
  setup(props, {
    slots
  }) {
    const {
      mainStyles
    } = useMain();
    const {
      ssrBootStyles
    } = useSsrBoot();
    return () => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": "v-main",
        "style": [mainStyles.value, ssrBootStyles.value]
      }, {
        default: () => [createVNode("div", {
          "class": "v-main__wrap"
        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)])]
      }, 8, ["style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VNavigationDrawer/VNavigationDrawer.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VNavigationDrawer/VNavigationDrawer.sass";
var VNavigationDrawer_default = defineComponent2({
  name: "VNavigationDrawer",
  props: {
    color: String,
    disableResizeWatcher: Boolean,
    expandOnHover: Boolean,
    floating: Boolean,
    modelValue: {
      type: Boolean,
      default: null
    },
    permanent: Boolean,
    rail: Boolean,
    railWidth: {
      type: [Number, String],
      default: 72
    },
    image: String,
    temporary: Boolean,
    width: {
      type: [Number, String],
      default: 256
    },
    position: {
      type: String,
      default: "left",
      validator: (value) => ["left", "right", "bottom"].includes(value)
    },
    ...makeBorderProps(),
    ...makeElevationProps(),
    ...makeLayoutItemProps(),
    ...makeRoundedProps(),
    ...makeTagProps({
      tag: "nav"
    }),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-navigation-drawer");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      elevationClasses
    } = useElevation(props);
    const {
      mobile
    } = useDisplay();
    const {
      roundedClasses
    } = useRounded(props, "v-navigation-drawer");
    const isActive = useProxiedModel(props, "modelValue");
    const isHovering = ref(false);
    const width = computed(() => {
      return props.rail && props.expandOnHover && isHovering.value ? props.width : Number(props.rail ? props.railWidth : props.width);
    });
    const isTemporary = computed(() => !props.permanent && (mobile.value || props.temporary));
    const layoutStyles = useLayoutItem(props.name, toRef(props, "priority"), toRef(props, "position"), computed(() => isTemporary.value ? 0 : props.rail && props.expandOnHover ? Number(props.railWidth) : width.value), width, isActive);
    if (!props.disableResizeWatcher) {
      watch(mobile, (val) => !props.permanent && (isActive.value = !val));
    }
    watch(props, (val) => {
      if (val.permanent)
        isActive.value = true;
    });
    onBeforeMount(() => {
      if (props.modelValue != null)
        return;
      isActive.value = props.permanent || !mobile.value;
    });
    return () => {
      var _slots$image, _slots$prepend, _slots$default, _slots$append;
      const hasImage = slots.image || props.image;
      return createVNode(props.tag, {
        "onMouseenter": () => isHovering.value = true,
        "onMouseleave": () => isHovering.value = false,
        "class": ["v-navigation-drawer", {
          "v-navigation-drawer--bottom": props.position === "bottom",
          "v-navigation-drawer--end": props.position === "right",
          "v-navigation-drawer--expand-on-hover": props.expandOnHover,
          "v-navigation-drawer--floating": props.floating,
          "v-navigation-drawer--is-hovering": isHovering.value,
          "v-navigation-drawer--rail": props.rail,
          "v-navigation-drawer--start": props.position === "left",
          "v-navigation-drawer--temporary": isTemporary.value,
          "v-navigation-drawer--absolute": props.absolute
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, layoutStyles.value]
      }, {
        default: () => [hasImage && createVNode("div", {
          "class": "v-navigation-drawer__img"
        }, [slots.image ? (_slots$image = slots.image) == null ? void 0 : _slots$image.call(slots, {
          image: props.image
        }) : createVNode("img", {
          "src": props.image,
          "alt": ""
        }, null, 8, ["src"])]), slots.prepend && createVNode("div", {
          "class": "v-navigation-drawer__prepend"
        }, [(_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots)]), createVNode("div", {
          "class": "v-navigation-drawer__content"
        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), slots.append && createVNode("div", {
          "class": "v-navigation-drawer__append"
        }, [(_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots)])],
        _: 1
      }, 8, ["onMouseenter", "onMouseleave", "class", "style"]);
    };
  }
});

// node_modules/vuetify/lib/components/VPagination/VPaginationBtn.mjs
var VPaginationBtn_default = defineComponent2({
  ...VBtn_default,
  name: "VPaginationBtn"
});

// node_modules/vuetify/lib/components/VPagination/VPagination.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VPagination/VPagination.sass";

// node_modules/vuetify/lib/composables/resizeObserver.mjs
function useResizeObserver(callback) {
  const resizeRef = ref();
  const contentRect = ref();
  const contentBoxSize = ref();
  const borderBoxSize = ref();
  const observer = new ResizeObserver((entries) => {
    callback == null ? void 0 : callback(entries, observer);
    if (!entries.length)
      return;
    contentRect.value = entries[0].contentRect;
    contentBoxSize.value = entries[0].contentBoxSize[0];
    borderBoxSize.value = entries[0].borderBoxSize[0];
  });
  onBeforeUnmount(() => {
    observer.disconnect();
  });
  watch(resizeRef, (newValue, oldValue) => {
    if (oldValue) {
      observer.unobserve(oldValue);
      contentRect.value = void 0;
      contentBoxSize.value = void 0;
      borderBoxSize.value = void 0;
    }
    if (newValue)
      observer.observe(newValue);
  }, {
    flush: "post"
  });
  return {
    resizeRef,
    contentRect: readonly(contentRect),
    contentBoxSize: readonly(contentBoxSize),
    borderBoxSize: readonly(borderBoxSize)
  };
}

// node_modules/vuetify/lib/composables/refs.mjs
function useRefs() {
  const refs = ref([]);
  onBeforeUpdate(() => refs.value = []);
  function updateRef(e, i) {
    refs.value[i] = e;
  }
  return {
    refs,
    updateRef
  };
}

// node_modules/vuetify/lib/components/VPagination/VPagination.mjs
var VPagination_default = defineComponent2({
  name: "VPagination",
  props: {
    start: {
      type: [Number, String],
      default: 1
    },
    modelValue: {
      type: Number,
      default: (props) => props.start
    },
    disabled: Boolean,
    length: {
      type: [Number, String],
      default: 1,
      validator: (val) => val % 1 === 0
    },
    totalVisible: [Number, String],
    firstIcon: {
      type: String,
      default: "$first"
    },
    prevIcon: {
      type: String,
      default: "$prev"
    },
    nextIcon: {
      type: String,
      default: "$next"
    },
    lastIcon: {
      type: String,
      default: "$last"
    },
    ariaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.root"
    },
    pageAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.page"
    },
    currentPageAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.currentPage"
    },
    firstAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.first"
    },
    previousAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.previous"
    },
    nextAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.next"
    },
    lastAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.last"
    },
    ellipsis: {
      type: String,
      default: "..."
    },
    showFirstLastPage: Boolean,
    ...makeTagProps({
      tag: "nav"
    }),
    ...makeElevationProps(),
    ...makeDensityProps(),
    ...makeRoundedProps(),
    ...makeSizeProps(),
    ...makeBorderProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "text"
    })
  },
  emits: {
    "update:modelValue": (value) => true,
    first: (value) => true,
    prev: (value) => true,
    next: (value) => true,
    last: (value) => true
  },
  setup(props, {
    slots,
    emit
  }) {
    const page = useProxiedModel(props, "modelValue");
    const {
      t,
      n
    } = useLocale();
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = useTheme(props);
    const maxButtons = ref(-1);
    const {
      resizeRef
    } = useResizeObserver((entries) => {
      if (!entries.length)
        return;
      const {
        target,
        contentRect
      } = entries[0];
      const firstItem = target.querySelector(".v-pagination__list > *");
      if (!firstItem)
        return;
      const totalWidth = contentRect.width;
      const itemWidth = firstItem.getBoundingClientRect().width + 10;
      maxButtons.value = Math.max(0, Math.floor((totalWidth - 96) / itemWidth));
    });
    const length = computed(() => parseInt(props.length, 10));
    const start = computed(() => parseInt(props.start, 10));
    const totalVisible = computed(() => {
      var _props$totalVisible;
      if (props.totalVisible)
        return Math.min(parseInt((_props$totalVisible = props.totalVisible) != null ? _props$totalVisible : "", 10), length.value);
      else if (maxButtons.value >= 0)
        return maxButtons.value;
      return length.value;
    });
    const range = computed(() => {
      if (length.value <= 0)
        return [];
      if (totalVisible.value <= 3) {
        return [Math.min(Math.max(start.value, page.value), start.value + length.value)];
      }
      if (props.length <= totalVisible.value) {
        return createRange(length.value, start.value);
      }
      const middle = Math.ceil(totalVisible.value / 2);
      const left = middle;
      const right = length.value - middle;
      if (page.value < left) {
        return [...createRange(Math.max(1, totalVisible.value - 2), start.value), props.ellipsis, length.value];
      } else if (page.value > right) {
        const rangeLength = totalVisible.value - 2;
        const rangeStart = length.value - rangeLength + start.value;
        return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart)];
      } else {
        const rangeLength = Math.max(1, totalVisible.value - 4);
        const rangeStart = rangeLength === 1 ? page.value : page.value - Math.ceil(rangeLength / 2) + start.value;
        return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart), props.ellipsis, length.value];
      }
    });
    function setValue(e, value, event) {
      e.preventDefault();
      page.value = value;
      event && emit(event, value);
    }
    const {
      refs,
      updateRef
    } = useRefs();
    const items = computed(() => {
      const sharedProps = {
        density: props.density,
        rounded: props.rounded,
        size: props.size
      };
      return range.value.map((item, index) => {
        const ref2 = (e) => updateRef(e, index);
        if (typeof item === "string") {
          return {
            isActive: false,
            page: item,
            props: {
              ...sharedProps,
              ref: ref2,
              ellipsis: true,
              icon: true,
              disabled: true,
              variant: props.variant,
              border: props.border
            }
          };
        } else {
          const isActive = item === page.value;
          return {
            isActive,
            page: n(item),
            props: {
              ...sharedProps,
              ref: ref2,
              ellipsis: false,
              icon: true,
              disabled: !!props.disabled || props.length < 2,
              elevation: props.elevation,
              variant: props.variant,
              border: props.border,
              color: isActive ? props.color : void 0,
              ariaCurrent: isActive,
              ariaLabel: t(isActive ? props.currentPageAriaLabel : props.pageAriaLabel, index + 1),
              onClick: (e) => setValue(e, item)
            }
          };
        }
      });
    });
    const controls = computed(() => {
      const sharedProps = {
        color: void 0,
        density: props.density,
        rounded: props.rounded,
        size: props.size,
        variant: props.variant,
        border: props.border
      };
      const prevDisabled = !!props.disabled || page.value <= start.value;
      const nextDisabled = !!props.disabled || page.value >= start.value + length.value - 1;
      return {
        first: props.showFirstLastPage ? {
          ...sharedProps,
          icon: isRtl.value ? props.lastIcon : props.firstIcon,
          onClick: (e) => setValue(e, start.value, "first"),
          disabled: prevDisabled,
          ariaLabel: t(props.firstAriaLabel),
          ariaDisabled: prevDisabled
        } : void 0,
        prev: {
          ...sharedProps,
          icon: isRtl.value ? props.nextIcon : props.prevIcon,
          onClick: (e) => setValue(e, page.value - 1, "prev"),
          disabled: prevDisabled,
          ariaLabel: t(props.previousAriaLabel),
          ariaDisabled: prevDisabled
        },
        next: {
          ...sharedProps,
          icon: isRtl.value ? props.prevIcon : props.nextIcon,
          onClick: (e) => setValue(e, page.value + 1, "next"),
          disabled: nextDisabled,
          ariaLabel: t(props.nextAriaLabel),
          ariaDisabled: nextDisabled
        },
        last: props.showFirstLastPage ? {
          ...sharedProps,
          icon: isRtl.value ? props.firstIcon : props.lastIcon,
          onClick: (e) => setValue(e, start.value + length.value - 1, "last"),
          disabled: nextDisabled,
          ariaLabel: t(props.lastAriaLabel),
          ariaDisabled: nextDisabled
        } : void 0
      };
    });
    function updateFocus() {
      var _refs$value$currentIn;
      const currentIndex = page.value - start.value;
      (_refs$value$currentIn = refs.value[currentIndex]) == null ? void 0 : _refs$value$currentIn.$el.focus();
    }
    function onKeydown(e) {
      if (e.key === keyValues.left && !props.disabled && page.value > props.start) {
        page.value = page.value - 1;
        nextTick(updateFocus);
      } else if (e.key === keyValues.right && !props.disabled && page.value < start.value + length.value - 1) {
        page.value = page.value + 1;
        nextTick(updateFocus);
      }
    }
    return () => createVNode(props.tag, {
      "ref": resizeRef,
      "class": ["v-pagination", themeClasses.value],
      "role": "navigation",
      "aria-label": t(props.ariaLabel),
      "onKeydown": onKeydown,
      "data-test": "v-pagination-root"
    }, {
      default: () => [createVNode("ul", {
        "class": "v-pagination__list"
      }, [props.showFirstLastPage && createVNode("li", {
        "class": "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [slots.first ? slots.first(controls.value.first) : createVNode(VPaginationBtn_default, controls.value.first, null, 16)]), createVNode("li", {
        "class": "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [slots.prev ? slots.prev(controls.value.prev) : createVNode(VPaginationBtn_default, controls.value.prev, null, 16)]), items.value.map((item, index) => createVNode("li", {
        "key": `${index}_${item.page}`,
        "class": ["v-pagination__item", {
          "v-pagination__item--is-active": item.isActive
        }],
        "data-test": "v-pagination-item"
      }, [slots.item ? slots.item(item) : createVNode(VPaginationBtn_default, item.props, {
        default: () => [item.page]
      }, 16)], 2)), createVNode("li", {
        "class": "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [slots.next ? slots.next(controls.value.next) : createVNode(VPaginationBtn_default, controls.value.next, null, 16)]), props.showFirstLastPage && createVNode("li", {
        "class": "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [slots.last ? slots.last(controls.value.last) : createVNode(VPaginationBtn_default, controls.value.last, null, 16)])])]
    }, 8, ["class", "aria-label", "onKeydown"]);
  }
});

// node_modules/vuetify/lib/components/VSheet/VSheet.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VSheet/VSheet.sass";
var VSheet_default = defineComponent2({
  name: "VSheet",
  props: {
    color: {
      type: String,
      default: "surface"
    },
    ...makeBorderProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      borderClasses
    } = useBorder(props, "v-sheet");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, "v-sheet");
    const {
      roundedClasses
    } = useRounded(props, "v-sheet");
    return () => createVNode(props.tag, {
      "class": ["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value],
      "style": [backgroundColorStyles.value, dimensionStyles.value, positionStyles.value]
    }, slots, 8, ["class", "style"]);
  }
});

// node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.sass";

// node_modules/vuetify/lib/composables/intersectionObserver.mjs
function useIntersectionObserver(callback) {
  const intersectionRef = ref();
  const isIntersecting = ref(false);
  const observer = new IntersectionObserver((entries) => {
    callback == null ? void 0 : callback(entries, observer);
    isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
  });
  onBeforeUnmount(() => {
    observer.disconnect();
  });
  watch(intersectionRef, (newValue, oldValue) => {
    if (oldValue) {
      observer.unobserve(oldValue);
      isIntersecting.value = false;
    }
    if (newValue)
      observer.observe(newValue);
  }, {
    flush: "post"
  });
  return {
    intersectionRef,
    isIntersecting
  };
}

// node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.mjs
var VProgressCircular_default = defineComponent2({
  name: "VProgressCircular",
  props: {
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
      type: [Number, String],
      default: 0
    },
    rotate: {
      type: [Number, String],
      default: 0
    },
    width: {
      type: [Number, String],
      default: 4
    },
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "div"
    }),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const MAGIC_RADIUS_CONSTANT = 20;
    const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
    const {
      themeClasses
    } = useTheme(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props, "v-progress-circular");
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    const {
      textColorClasses: underlayColorClasses,
      textColorStyles: underlayColorStyles
    } = useTextColor(toRef(props, "bgColor"));
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const normalizedValue = computed(() => Math.max(0, Math.min(100, parseFloat(props.modelValue))));
    const width = computed(() => Number(props.width));
    const size = computed(() => {
      return sizeStyles.value ? Number(props.size) : intersectionRef.value ? intersectionRef.value.getBoundingClientRect().width : Math.max(width.value, 32);
    });
    const diameter = computed(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size.value) * 2);
    const strokeWidth = computed(() => width.value / size.value * diameter.value);
    const strokeDashOffset = computed(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
    return () => createVNode(props.tag, {
      "ref": intersectionRef,
      "class": ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!props.indeterminate,
        "v-progress-circular--visible": isIntersecting.value,
        "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
      }, themeClasses.value, sizeClasses.value, textColorClasses.value],
      "style": [sizeStyles.value, textColorStyles.value],
      "role": "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
    }, {
      default: () => [createVNode("svg", {
        "style": {
          transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
        },
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": `0 0 ${diameter.value} ${diameter.value}`
      }, [createVNode("circle", {
        "class": ["v-progress-circular__underlay", underlayColorClasses.value],
        "style": underlayColorStyles.value,
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": 0
      }, null, 14, ["r", "stroke-width", "stroke-dasharray"]), createVNode("circle", {
        "class": "v-progress-circular__overlay",
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": strokeDashOffset.value
      }, null, 8, ["r", "stroke-width", "stroke-dasharray", "stroke-dashoffset"])]), slots.default && createVNode("div", {
        "class": "v-progress-circular__content"
      }, [slots.default({
        value: normalizedValue.value
      })])],
      _: 1
    }, 8, ["class", "style", "aria-valuenow"]);
  }
});

// node_modules/vuetify/lib/components/VRating/VRating.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VRating/VRating.sass";
var VRating_default = defineComponent2({
  name: "VRating",
  props: {
    name: String,
    itemAriaLabel: {
      type: String,
      default: "$vuetify.rating.ariaLabel.item"
    },
    activeColor: String,
    color: String,
    clearable: Boolean,
    disabled: Boolean,
    emptyIcon: {
      type: String,
      default: "$ratingEmpty"
    },
    fullIcon: {
      type: String,
      default: "$ratingFull"
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
      type: [Number, String],
      default: 5
    },
    readonly: Boolean,
    modelValue: {
      type: Number,
      default: 0
    },
    itemLabels: Array,
    itemLabelPosition: {
      type: String,
      default: "top",
      validator: (v) => ["top", "bottom"].includes(v)
    },
    ripple: Boolean,
    ...makeDensityProps(),
    ...makeSizeProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, {
    slots
  }) {
    const {
      t
    } = useLocale();
    const {
      themeClasses
    } = useTheme(props);
    const rating = useProxiedModel(props, "modelValue");
    const range = computed(() => createRange(Number(props.length), 1));
    const increments = computed(() => range.value.flatMap((v) => props.halfIncrements ? [v - 0.5, v] : [v]));
    const hoverIndex = ref(-1);
    const focusIndex = ref(-1);
    const firstRef = ref();
    let isClicking = false;
    const itemState = computed(() => increments.value.map((value) => {
      var _props$activeColor;
      const isHovering = props.hover && hoverIndex.value > -1;
      const isFilled = rating.value >= value;
      const isHovered = hoverIndex.value >= value;
      const isFullIcon = isHovering ? isHovered : isFilled;
      const icon = isFullIcon ? props.fullIcon : props.emptyIcon;
      const activeColor = (_props$activeColor = props.activeColor) != null ? _props$activeColor : props.color;
      const color = isFilled || isHovered ? activeColor : props.color;
      return {
        isFilled,
        isHovered,
        icon,
        color
      };
    }));
    const eventState = computed(() => [0, ...increments.value].map((value) => {
      function onMouseenter() {
        hoverIndex.value = value;
      }
      function onMouseleave() {
        hoverIndex.value = -1;
      }
      function onFocus() {
        if (value === 0 && rating.value === 0) {
          var _firstRef$value;
          (_firstRef$value = firstRef.value) == null ? void 0 : _firstRef$value.focus();
        } else {
          focusIndex.value = value;
        }
      }
      function onBlur() {
        if (!isClicking)
          focusIndex.value = -1;
      }
      function onClick() {
        if (props.disabled || props.readonly)
          return;
        rating.value = rating.value === value && props.clearable ? 0 : value;
      }
      return {
        onMouseenter: props.hover ? onMouseenter : void 0,
        onMouseleave: props.hover ? onMouseleave : void 0,
        onFocus,
        onBlur,
        onClick
      };
    }));
    function onMousedown() {
      isClicking = true;
    }
    function onMouseup() {
      isClicking = false;
    }
    const name = computed(() => {
      var _props$name;
      return (_props$name = props.name) != null ? _props$name : `v-rating-${getUid()}`;
    });
    function VRatingItem({
      value,
      index,
      showStar = true
    }) {
      var _itemState$value$inde, _itemState$value$inde2;
      const {
        onMouseenter,
        onMouseleave,
        onFocus,
        onBlur,
        onClick
      } = eventState.value[index + 1];
      const id = `${name.value}-${String(value).replace(".", "-")}`;
      const btnProps = {
        color: (_itemState$value$inde = itemState.value[index]) == null ? void 0 : _itemState$value$inde.color,
        density: props.density,
        disabled: props.disabled,
        icon: (_itemState$value$inde2 = itemState.value[index]) == null ? void 0 : _itemState$value$inde2.icon,
        ripple: props.ripple,
        size: props.size,
        tag: "span",
        variant: "plain"
      };
      return createVNode(Fragment, null, [createVNode("label", {
        "for": id,
        "class": {
          "v-rating__item--half": props.halfIncrements && value % 1 > 0,
          "v-rating__item--full": props.halfIncrements && value % 1 === 0
        },
        "onMousedown": onMousedown,
        "onMouseup": onMouseup,
        "onMouseenter": onMouseenter,
        "onMouseleave": onMouseleave
      }, [createVNode("span", {
        "class": "v-rating__hidden"
      }, [t(props.itemAriaLabel, value, props.length)]), !showStar ? void 0 : slots.item ? slots.item({
        ...itemState.value,
        props: btnProps,
        value,
        index
      }) : createVNode(VBtn_default, btnProps, null, 16)], 42, ["for", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave"]), createVNode("input", {
        "class": "v-rating__hidden",
        "name": name.value,
        "id": id,
        "type": "radio",
        "value": value,
        "checked": rating.value === value,
        "onClick": onClick,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "ref": index === 0 ? firstRef : void 0,
        "readonly": props.readonly,
        "disabled": props.disabled
      }, null, 40, ["name", "id", "value", "checked", "onClick", "onFocus", "onBlur", "readonly", "disabled"])]);
    }
    return () => {
      var _props$itemLabels;
      const hasLabels = !!((_props$itemLabels = props.itemLabels) != null && _props$itemLabels.length);
      return createVNode(props.tag, {
        "class": ["v-rating", {
          "v-rating--readonly": props.readonly
        }, themeClasses.value]
      }, {
        default: () => [createVNode(VRatingItem, {
          "value": 0,
          "index": -1,
          "showStar": false
        }, null, 8, ["index"]), range.value.map((value, i) => {
          var _props$itemLabels2, _props$itemLabels3;
          return createVNode("div", {
            "class": "v-rating__wrapper"
          }, [!hasLabels ? void 0 : slots["item-label"] ? slots["item-label"]() : (_props$itemLabels2 = props.itemLabels) != null && _props$itemLabels2[i] ? createVNode("span", null, [(_props$itemLabels3 = props.itemLabels) == null ? void 0 : _props$itemLabels3[i]]) : createVNode("span", null, [createTextVNode("\xA0")]), createVNode("div", {
            "class": ["v-rating__item", {
              "v-rating__item--focused": Math.ceil(focusIndex.value) === value
            }]
          }, [props.halfIncrements ? createVNode(Fragment, null, [createVNode(VRatingItem, {
            "value": value - 0.5,
            "index": i * 2
          }, null, 8, ["value", "index"]), createVNode(VRatingItem, {
            "value": value,
            "index": i * 2 + 1
          }, null, 8, ["value", "index"])]) : createVNode(VRatingItem, {
            "value": value,
            "index": i
          }, null, 8, ["value", "index"])], 2)]);
        })],
        _: 1
      }, 8, ["class"]);
    };
  }
});

// node_modules/vuetify/lib/components/VSystemBar/VSystemBar.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VSystemBar/VSystemBar.sass";
var VSystemBar_default = defineComponent2({
  name: "VSystemBar",
  props: {
    lightsOut: Boolean,
    window: Boolean,
    ...makeBorderProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, "v-system-bar");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, "v-system-bar");
    const {
      roundedClasses
    } = useRounded(props, "v-system-bar");
    return () => createVNode(props.tag, {
      "class": [{
        "v-system-bar": true,
        "v-system-bar--lights-out": props.lightsOut,
        "v-system-bar--window": props.window
      }, themeClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value],
      "style": [dimensionStyles.value, positionStyles.value]
    }, slots, 8, ["class", "style"]);
  }
});

// node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.sass";
var VThemeProvider_default = defineComponent2({
  name: "VThemeProvider",
  props: {
    withBackground: Boolean,
    ...makeThemeProps(),
    ...makeTagProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    return () => {
      var _slots$default, _slots$default2;
      if (!props.withBackground)
        return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
      return createVNode(props.tag, {
        "class": ["v-theme-provider", themeClasses.value]
      }, {
        default: () => [(_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)]
      }, 8, ["class"]);
    };
  }
});

// node_modules/vuetify/lib/components/VTimeline/shared.mjs
var VTimelineSymbol = Symbol.for("vuetify:timeline");

// node_modules/vuetify/lib/components/VTimeline/VTimelineDivider.mjs
var VTimelineDivider_default = defineComponent({
  name: "VTimelineDivider",
  props: {
    hideDot: Boolean,
    lineColor: String,
    icon: String,
    iconColor: String,
    fillDot: Boolean,
    dotColor: String,
    ...makeRoundedProps(),
    ...makeSizeProps(),
    ...makeElevationProps()
  },
  setup(props, {
    slots
  }) {
    const timeline = inject(VTimelineSymbol);
    if (!timeline)
      throw new Error("[Vuetify] Could not find v-timeline provider");
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props, "v-timeline-divider__dot");
    const {
      backgroundColorStyles,
      backgroundColorClasses
    } = useBackgroundColor(toRef(props, "dotColor"));
    const {
      backgroundColorStyles: lineColorStyles,
      backgroundColorClasses: lineColorClasses
    } = useBackgroundColor(timeline.lineColor);
    const {
      roundedClasses
    } = useRounded(props, "v-timeline-divider__dot");
    const {
      elevationClasses
    } = useElevation(props);
    return () => createVNode("div", {
      "class": ["v-timeline-divider", {
        "v-timeline-divider--fill-dot": props.fillDot
      }]
    }, [!props.hideDot && createVNode("div", {
      "class": ["v-timeline-divider__dot", roundedClasses.value, sizeClasses.value, elevationClasses.value],
      "style": sizeStyles.value
    }, [createVNode("div", {
      "class": ["v-timeline-divider__inner-dot", roundedClasses.value, backgroundColorClasses.value],
      "style": backgroundColorStyles.value
    }, [slots.default ? slots.default({
      icon: props.icon,
      iconColor: props.iconColor,
      size: props.size
    }) : props.icon ? createVNode(VIcon_default, {
      "icon": props.icon,
      "color": props.iconColor,
      "size": props.size
    }, null, 8, ["icon", "color", "size"]) : void 0], 6)], 6), createVNode("div", {
      "class": ["v-timeline-divider__line", lineColorClasses.value],
      "style": lineColorStyles.value
    }, null, 6)], 2);
  }
});

// node_modules/vuetify/lib/components/VTimeline/VTimelineItem.mjs
var VTimelineItem_default = defineComponent2({
  name: "VTimelineItem",
  props: {
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    hideOpposite: {
      type: Boolean,
      default: void 0
    },
    icon: String,
    iconColor: String,
    ...makeRoundedProps(),
    ...makeElevationProps(),
    ...makeSizeProps(),
    ...makeTagProps(),
    ...makeDimensionProps()
  },
  setup(props, {
    slots
  }) {
    const timeline = inject(VTimelineSymbol);
    if (!timeline)
      throw new Error("[Vuetify] Could not find v-timeline provider");
    const {
      dimensionStyles
    } = useDimension(props);
    const dotSize = ref(0);
    const dotRef = ref();
    watch(dotRef, (newValue) => {
      var _newValue$$el$querySe, _newValue$$el$querySe2;
      if (!newValue)
        return;
      dotSize.value = (_newValue$$el$querySe = (_newValue$$el$querySe2 = newValue.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : _newValue$$el$querySe2.getBoundingClientRect().width) != null ? _newValue$$el$querySe : 0;
    }, {
      flush: "post"
    });
    return () => {
      var _slots$default, _slots$opposite;
      return createVNode("div", {
        "class": ["v-timeline-item", {
          "v-timeline-item--fill-dot": props.fillDot
        }],
        "style": {
          "--v-timeline-dot-size": convertToUnit(dotSize.value)
        }
      }, [createVNode("div", {
        "class": "v-timeline-item__body",
        "style": dimensionStyles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 4), createVNode(VTimelineDivider_default, {
        "ref": dotRef,
        "hideDot": props.hideDot,
        "icon": props.icon,
        "iconColor": props.iconColor,
        "size": props.size,
        "elevation": props.elevation,
        "dotColor": props.dotColor,
        "fillDot": props.fillDot,
        "rounded": props.rounded
      }, {
        default: slots.icon
      }, 8, ["hideDot", "icon", "iconColor", "size", "elevation", "dotColor", "fillDot", "rounded"]), timeline.density.value !== "compact" && createVNode("div", {
        "class": "v-timeline-item__opposite"
      }, [!props.hideOpposite && ((_slots$opposite = slots.opposite) == null ? void 0 : _slots$opposite.call(slots))])], 6);
    };
  }
});

// node_modules/vuetify/lib/components/VTimeline/VTimeline.mjs
import "/home/alfred/repos/personal/ajc-client/node_modules/vuetify/lib/components/VTimeline/VTimeline.sass";
var VTimeline_default = defineComponent2({
  name: "VTimeline",
  props: {
    direction: {
      type: String,
      default: "vertical",
      validator: (v) => ["vertical", "horizontal"].includes(v)
    },
    side: {
      type: String,
      validator: (v) => v == null || ["start", "end"].includes(v)
    },
    lineInset: {
      type: [String, Number],
      default: 0
    },
    lineThickness: {
      type: [String, Number],
      default: 2
    },
    lineColor: String,
    truncateLine: {
      type: String,
      default: "start",
      validator: (v) => ["none", "start", "end", "both"].includes(v)
    },
    ...makeDensityProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      densityClasses
    } = useDensity(props, "v-timeline");
    provide(VTimelineSymbol, {
      density: toRef(props, "density"),
      lineColor: toRef(props, "lineColor")
    });
    const sideClass = computed(() => {
      const side = props.side ? props.side : props.density !== "default" ? "end" : null;
      return side && `v-timeline--side-${side}`;
    });
    return () => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-timeline", `v-timeline--${props.direction}`, {
          "v-timeline--inset-line": !!props.lineInset,
          "v-timeline--truncate-line-end": props.truncateLine === "end" || props.truncateLine === "both"
        }, themeClasses.value, densityClasses.value, sideClass.value],
        "style": {
          "--v-timeline-line-thickness": convertToUnit(props.lineThickness),
          "--v-timeline-line-inset": convertToUnit(props.lineInset || void 0)
        }
      }, {
        default: () => [(props.truncateLine === "none" || props.truncateLine === "end") && createVNode(VTimelineItem_default, {
          "hideDot": true
        }, null, 8, ["hideDot"]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }
});

export {
  ThemeSymbol,
  createTheme,
  RtlSymbol,
  createRtl,
  VApp_default,
  VResponsive_default,
  VImg_default,
  VAppBar_default,
  IconSymbol,
  VComponentIcon,
  VSvgIcon,
  VLigatureIcon,
  VClassIcon,
  defaultSets,
  VIcon_default,
  VBtn_default,
  VAppBarNavIcon_default,
  VAppBarTitle_default,
  VAvatar_default,
  VAlert_default,
  VBadge_default,
  VBannerActions_default,
  VBannerAvatar_default,
  VBannerContent_default,
  VBannerText_default,
  DisplaySymbol,
  createDisplay,
  VBanner_default,
  VBottomNavigation_default,
  VBreadcrumbsItem_default,
  VBreadcrumbsDivider_default,
  VBreadcrumbs_default,
  VCardActions_default,
  VCardAvatar_default,
  VCardHeader_default,
  VCardHeaderText_default,
  VCardImg_default,
  VCardSubtitle_default,
  VCardText_default,
  VCardTitle_default,
  VCard_default,
  VChip_default,
  VCode,
  VDefaultsProvider_default,
  dialog_transition_default,
  VCarouselTransition,
  VCarouselReverseTransition,
  VTabTransition,
  VTabReverseTransition,
  VMenuTransition,
  VFabTransition,
  VDialogBottomTransition,
  VDialogTopTransition,
  VFadeTransition,
  VScaleTransition,
  VScrollXTransition,
  VScrollXReverseTransition,
  VScrollYTransition,
  VScrollYReverseTransition,
  VSlideXTransition,
  VSlideXReverseTransition,
  VSlideYTransition,
  VSlideYReverseTransition,
  VExpandTransition,
  VExpandXTransition,
  VOverlay_default,
  VDialog_default,
  VDivider_default,
  VFooter_default,
  VContainer_default,
  VCol_default,
  VRow_default,
  VSpacer_default,
  VHover_default,
  VInputLabel_default,
  VInput_default,
  VKbd,
  VItemGroup_default,
  VItem_default,
  VLayout_default,
  VLayoutItem_default,
  LocaleAdapterSymbol,
  createLocaleAdapter,
  VLocaleProvider_default,
  VListSubheader_default,
  VList_default,
  VListImg_default,
  VListItemAvatar_default,
  VListItemHeader_default,
  VListItemSubtitle_default,
  VListItemTitle_default,
  VListItem_default,
  VListItemMedia_default,
  VLazy_default,
  VMain_default,
  VNavigationDrawer_default,
  VPaginationBtn_default,
  VPagination_default,
  VSheet_default,
  VProgressCircular_default,
  VRating_default,
  VSystemBar_default,
  VThemeProvider_default,
  VTimelineItem_default,
  VTimeline_default
};
//# sourceMappingURL=chunk-GLUZTQQE.js.map
